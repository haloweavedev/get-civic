This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-03T03:10:16.296Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
prisma/
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  robots.txt
  site.webmanifest
  vercel.svg
  window.svg
src/
  app/
    (auth)/
      dashboard/
        integrations/
          gmail/
            gmail-integration-client.tsx
            page.tsx
          twilio/
            page.tsx
        settings/
          page.tsx
        layout.tsx
        page.tsx
    api/
      auth/
        callback/
          route.ts
        sync/
          route.ts
      communications/
        route.ts
      integrations/
        gmail/
          auth/
            route.ts
          callback/
            route.ts
          disconnect/
            route.ts
          sync/
            route.ts
      test/
        route.ts
      test-call/
        route.ts
      webhooks/
        gmail/
          route.ts
        twilio/
          sms/
            route.ts
          test/
            route.ts
          voice/
            recording/
              route.ts
            transcription/
              route.ts
            route.ts
    dashboard/
      settings/
        email/
          layout.tsx
          page.tsx
    sign-in/
      [[...sign-in]]/
        page.tsx
    sign-up/
      [[...sign-up]]/
        page.tsx
    globals.css
    layout.tsx
    loading.tsx
    not-found.tsx
    page.tsx
  components/
    dashboard/
      communications/
        communications-dashboard.tsx
      integrations/
        integrations-status.tsx
      dashboard-content.tsx
      user-greeting.tsx
      user-info.tsx
      user-welcome.tsx
    providers/
      query-provider.tsx
    ui/
      avatar.tsx
      badge.tsx
      button.tsx
      card.tsx
      dropdown-menu.tsx
      input.tsx
      label.tsx
      separator.tsx
      sheet.tsx
      tabs.tsx
    error-boundary.tsx
  config/
    metadata.ts
  lib/
    integrations/
      gmail/
        client.ts
        processor.ts
        types.ts
      twilio/
        handlers/
          call.ts
          processor.ts
          sms.ts
        sms/
          route.ts
        voice/
          route.ts
        client.ts
        types.ts
      debug.ts
      errors.ts
      types.ts
      utils.ts
    auth.ts
    prisma.ts
    utils.ts
  scripts/
    debug-user.ts
    dev.ts
    reset-db.ts
    setup.ts
  middleware.ts
.eslintignore
.eslintrc.json
.gitignore
components.json
next.config.mjs
package.json
postcss.config.mjs
progress-nov-1.md
progress-nov-2.md
project-plan.md
README.md
tailwind.config.ts
tsconfig.json
vercel.json

================================================================
Repository Files
================================================================

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  role      UserRole @default(USER)
  settings  Json?    @default("{}")
  apiKey    String?  @unique // For API access
  
  // Usage and limits
  apiUsage  Int      @default(0)
  apiLimit  Int      @default(1000)
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  communications Communication[]
  organizations  OrganizationMember[]
}

enum UserRole {
  ADMIN
  USER
  VIEWER
}

model Organization {
  id          String   @id @default(cuid())
  name        String
  settings    Json?    @default("{}")
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  members         OrganizationMember[]
  communications  Communication[]
}

model OrganizationMember {
  id             String       @id @default(cuid())
  organizationId String
  userId         String
  role           MemberRole   @default(MEMBER)
  
  // Relations
  organization   Organization @relation(fields: [organizationId], references: [id])
  user           User         @relation(fields: [userId], references: [id])
  
  // Timestamps
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@unique([organizationId, userId])
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
}

model Communication {
  id               String             @id @default(cuid())
  type             CommunicationType
  direction        Direction
  status           ProcessingStatus   @default(PENDING)
  rawContent       String             // Original content
  processedContent String?            // Cleaned/normalized content
  metadata         Json               // Source-specific metadata

  // Source identifiers
  sourceId         String?            // External ID (e.g., Twilio SID)
  source           String?            // Source system identifier

  // Participants
  participants     String[]           // Array of participant identifiers

  // Error handling
  errorDetails     String?
  retryCount       Int                @default(0)

  // Relationships
  organizationId   String?
  organization     Organization?      @relation(fields: [organizationId], references: [id])
  userId           String
  user             User               @relation(fields: [userId], references: [id])
  analysis         Analysis?

  // Timestamps
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  processedAt      DateTime?

  @@index([type, status])
  @@index([organizationId])
  @@index([userId])
}

enum CommunicationType {
  CALL
  SMS
  EMAIL
}

enum Direction {
  INBOUND
  OUTBOUND
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  PROCESSED
  FAILED
}

model Analysis {
  id              String    @id @default(cuid())
  version         String    // Analysis version/model used
  
  // Analysis results
  sentiment       Json      // Sentiment analysis results
  summary         String    // Generated summary
  categories      Json      // Detected categories
  entities        Json      // Extracted entities
  intentions      String[]  // Detected intentions
  priority        Int       @default(0)
  
  // Processing metadata
  language        String    // Detected language
  confidence      Float     // Analysis confidence score
  processingTime  Int       // Processing time in milliseconds
  
  // Relations
  communicationId String    @unique
  communication   Communication @relation(fields: [communicationId], references: [id])
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([communicationId])
}

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/robots.txt
================
User-agent: *
Allow: /

Sitemap: https://senate-insights.com/sitemap.xml

================
File: public/site.webmanifest
================
{
    "name": "Senate Insights",
    "short_name": "Senate",
    "icons": [
      {
        "src": "/android-chrome-192x192.png",
        "sizes": "192x192",
        "type": "image/png"
      },
      {
        "src": "/android-chrome-512x512.png",
        "sizes": "512x512",
        "type": "image/png"
      }
    ],
    "theme_color": "#ffffff",
    "background_color": "#ffffff",
    "display": "standalone"
  }

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: src/app/(auth)/dashboard/integrations/gmail/gmail-integration-client.tsx
================
// src/app/(auth)/dashboard/integrations/gmail/gmail-integration-client.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { toast } from 'sonner';
import { Loader2, Mail, CheckCircle, XCircle, RefreshCw, Clock, AlertCircle } from 'lucide-react';

type EmailPreview = {
  id: string;
  metadata: any;
  createdAt: Date;
  processedContent: string;
  status: string;
};

type Props = {
  isConnected: boolean;
  emailCount: number;
  lastSynced?: Date | null;
  userId: string;
  latestEmails: EmailPreview[];
};

export default function GmailIntegrationClient({
  isConnected,
  emailCount,
  lastSynced,
  userId,
  latestEmails
}: Props) {
  const [isConnecting, setIsConnecting] = useState(false);
  const [isSyncing, setIsSyncing] = useState(false);
  const [isDisconnecting, setIsDisconnecting] = useState(false);
  const router = useRouter();

  const handleConnect = async () => {
    try {
      setIsConnecting(true);
      const response = await fetch('/api/integrations/gmail/auth');
      const data = await response.json();
      
      if (data.authUrl) {
        window.location.href = data.authUrl;
      } else {
        throw new Error('No auth URL received');
      }
    } catch (error) {
      toast.error('Failed to start Gmail connection');
      console.error('Connection error:', error);
    } finally {
      setIsConnecting(false);
    }
  };

  const handleSync = async () => {
    if (!isConnected) {
      toast.error('Please connect Gmail first');
      return;
    }

    try {
      setIsSyncing(true);
      const response = await fetch('/api/integrations/gmail/sync', {
        method: 'POST'
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to sync');
      }

      const data = await response.json();
      toast.success(`Synced ${data.processed} new emails`);
      router.refresh();
    } catch (error) {
      const typedError = error as { code?: string; message?: string };
      if (typedError.code === 'INSUFFICIENT_SCOPES') {
        toast.error('Insufficient permissions. Please reconnect your Gmail account.');
        // Optionally redirect user to reconnect
      } else {
        toast.error('Failed to sync emails');
      }
    } finally {
      setIsSyncing(false);
    }
  };

  const handleDisconnect = async () => {
    try {
      setIsDisconnecting(true);
      const response = await fetch('/api/integrations/gmail/disconnect', {
        method: 'POST'
      });

      if (!response.ok) {
        throw new Error('Failed to disconnect');
      }

      toast.success('Gmail disconnected successfully');
      router.refresh();
    } catch (error) {
      toast.error('Failed to disconnect Gmail');
      console.error('Disconnect error:', error);
    } finally {
      setIsDisconnecting(false);
    }
  };

  const formatDate = (date: Date) => {
    return new Date(date).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'PROCESSED':
        return <Badge variant="default">Processed</Badge>;
      case 'PENDING':
        return <Badge variant="secondary">Pending</Badge>;
      case 'ERROR':
        return <Badge variant="destructive">Error</Badge>;
      default:
        return <Badge>{status}</Badge>;
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold tracking-tight">Gmail Integration</h2>
        <p className="text-muted-foreground">
          Connect your Gmail account to start analyzing email communications
        </p>
      </div>

      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>Connection Status</CardTitle>
              <CardDescription>Current status of your Gmail integration</CardDescription>
            </div>
            <Badge 
              variant={isConnected ? "default" : "destructive"}
              className="h-8"
            >
              {isConnected ? (
                <>
                  <CheckCircle className="mr-1 h-4 w-4" />
                  Connected
                </>
              ) : (
                <>
                  <XCircle className="mr-1 h-4 w-4" />
                  Disconnected
                </>
              )}
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {isConnected ? (
              <>
                <div className="grid grid-cols-3 gap-4 bg-muted p-4 rounded-lg">
                  <div>
                    <div className="text-sm font-medium text-muted-foreground">Total Emails</div>
                    <div className="text-2xl font-bold">{emailCount}</div>
                  </div>
                  {lastSynced && (
                    <div>
                      <div className="text-sm font-medium text-muted-foreground">Last Synced</div>
                      <div className="text-sm font-medium">
                        {formatDate(lastSynced)}
                      </div>
                    </div>
                  )}
                  <div>
                    <div className="text-sm font-medium text-muted-foreground">Email Account</div>
                    <div className="text-sm font-medium">haloweaveinsights@gmail.com</div>
                  </div>
                </div>

                <div className="flex gap-4">
                  <Button
                    onClick={handleSync}
                    disabled={isSyncing || isDisconnecting}
                  >
                    {isSyncing ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Syncing...
                      </>
                    ) : (
                      <>
                        <RefreshCw className="mr-2 h-4 w-4" />
                        Sync Emails
                      </>
                    )}
                  </Button>
                  <Button
                    variant="destructive"
                    onClick={handleDisconnect}
                    disabled={isDisconnecting || isSyncing}
                  >
                    {isDisconnecting ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Disconnecting...
                      </>
                    ) : (
                      <>
                        <XCircle className="mr-2 h-4 w-4" />
                        Disconnect
                      </>
                    )}
                  </Button>
                </div>

                {latestEmails.length > 0 && (
                  <>
                    <Separator className="my-4" />
                    <div>
                      <h3 className="text-lg font-semibold mb-4">Latest Emails</h3>
                      <div className="space-y-4">
                        {latestEmails.map((email) => (
                          <Card key={email.id}>
                            <CardContent className="pt-6">
                              <div className="flex justify-between items-start mb-2">
                                <div className="flex-1">
                                  <h4 className="font-medium">{email.metadata.subject}</h4>
                                  <p className="text-sm text-muted-foreground">
                                    From: {email.metadata.from.email}
                                  </p>
                                </div>
                                <div className="flex items-center space-x-2">
                                  {getStatusBadge(email.status)}
                                  <span className="text-sm text-muted-foreground">
                                    {formatDate(email.createdAt)}
                                  </span>
                                </div>
                              </div>
                              <p className="text-sm line-clamp-2">{email.processedContent}</p>
                            </CardContent>
                          </Card>
                        ))}
                      </div>
                    </div>
                  </>
                )}
              </>
            ) : (
              <div className="text-center py-8">
                <div className="bg-muted p-6 rounded-lg mb-6">
                  <AlertCircle className="mx-auto h-12 w-12 text-muted-foreground mb-4" />
                  <p className="text-muted-foreground">
                    Connect your Gmail account to start analyzing your email communications. 
                    We'll only read emails sent to haloweaveinsights@gmail.com.
                  </p>
                </div>
                <Button
                  size="lg"
                  onClick={handleConnect}
                  disabled={isConnecting}
                >
                  {isConnecting ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Connecting...
                    </>
                  ) : (
                    <>
                      <Mail className="mr-2 h-4 w-4" />
                      Connect Gmail
                    </>
                  )}
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

================
File: src/app/(auth)/dashboard/integrations/gmail/page.tsx
================
// src/app/(auth)/dashboard/integrations/gmail/page.tsx
import { auth } from '@clerk/nextjs/server';
import { prisma } from '@/lib/prisma';
import GmailIntegrationClient from './gmail-integration-client';
import { redirect } from 'next/navigation';

export default async function GmailSetupPage() {
    const { userId } = await auth();
    if (!userId) {
      redirect('/sign-in');
    }
  
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        settings: true,
        communications: {
          where: {
            source: 'GMAIL',
            type: 'EMAIL'
          },
          orderBy: {
            createdAt: 'desc'
          },
          take: 5,
          select: {
            id: true,
            metadata: true,
            createdAt: true,
            processedContent: true,
            status: true
          }
        }
      }
    });
  
    // Parse tokens if they're stored as string
    const settings = user?.settings as any;
    const gmailTokens = settings?.gmailTokens 
      ? (typeof settings.gmailTokens === 'string' 
          ? JSON.parse(settings.gmailTokens) 
          : settings.gmailTokens)
      : null;
  
    const isConnected = !!gmailTokens?.access_token;
    
    const stats = isConnected ? await prisma.communication.aggregate({
      where: {
        userId,
        source: 'GMAIL',
        type: 'EMAIL'
      },
      _count: true,
      _max: {
        createdAt: true
      }
    }) : null;
  
    return (
      <GmailIntegrationClient 
        isConnected={isConnected} 
        emailCount={stats?._count || 0}
        lastSynced={stats?._max.createdAt}
        userId={userId}
        latestEmails={user?.communications || []}
      />
    );
  }

================
File: src/app/(auth)/dashboard/integrations/twilio/page.tsx
================
// src/app/(auth)/dashboard/integrations/twilio/page.tsx
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { CheckCircle, XCircle, Phone, MessageSquare } from 'lucide-react';
import { prisma } from '@/lib/prisma';

export default async function TwilioSetupPage() {
  const { userId } = await auth();
  if (!userId) redirect('/sign-in');

  // Get Twilio stats
  const stats = await prisma.communication.groupBy({
    by: ['type'],
    where: {
      userId,
      source: 'TWILIO',
      type: {
        in: ['CALL', 'SMS']
      }
    },
    _count: true
  });

  const callCount = stats.find(s => s.type === 'CALL')?._count ?? 0;
  const smsCount = stats.find(s => s.type === 'SMS')?._count ?? 0;

  const isConfigured = process.env.TWILIO_ACCOUNT_SID && 
                      process.env.TWILIO_AUTH_TOKEN;

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold tracking-tight">Twilio Integration</h2>
        <p className="text-muted-foreground">
          Configure Twilio to handle phone calls and SMS communications
        </p>
      </div>

      <div className="grid gap-6">
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle>Connection Status</CardTitle>
                <CardDescription>Current status of your Twilio integration</CardDescription>
              </div>
              {isConfigured ? (
                <Badge variant="success" className="h-8">
                  <CheckCircle className="mr-1 h-4 w-4" />
                  Configured
                </Badge>
              ) : (
                <Badge variant="destructive" className="h-8">
                  <XCircle className="mr-1 h-4 w-4" />
                  Not Configured
                </Badge>
              )}
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-3 gap-4">
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <Phone className="h-4 w-4" />
                  <p className="text-sm text-muted-foreground">Total Calls</p>
                </div>
                <p className="text-2xl font-bold">{callCount}</p>
              </div>
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <MessageSquare className="h-4 w-4" />
                  <p className="text-sm text-muted-foreground">Total SMS</p>
                </div>
                <p className="text-2xl font-bold">{smsCount}</p>
              </div>
            </div>

            <div className="space-y-4">
              <div className="grid gap-2">
                <Label htmlFor="accountSid">Account SID</Label>
                <Input 
                  id="accountSid" 
                  value={process.env.TWILIO_ACCOUNT_SID} 
                  disabled 
                  type="password"
                />
              </div>

              <div className="grid gap-2">
                <Label htmlFor="phoneNumber">Phone Number</Label>
                <Input 
                  id="phoneNumber" 
                  value={process.env.TWILIO_PHONE_NUMBER} 
                  disabled
                />
              </div>

              <Button variant="outline">
                Update Configuration
              </Button>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Webhook Configuration</CardTitle>
            <CardDescription>
              Configure your Twilio webhooks to receive communications
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label>Voice Webhook URL</Label>
              <Input 
                value={`${process.env.NEXT_PUBLIC_URL}/api/webhooks/twilio/voice`}
                readOnly
              />
            </div>

            <div className="space-y-2">
              <Label>SMS Webhook URL</Label>
              <Input 
                value={`${process.env.NEXT_PUBLIC_URL}/api/webhooks/twilio/sms`}
                readOnly
              />
            </div>

            <div className="pt-4">
              <h4 className="font-medium mb-2">Instructions</h4>
              <ol className="text-sm text-muted-foreground list-decimal pl-4 space-y-2">
                <li>Copy these webhook URLs</li>
                <li>Go to your Twilio Console</li>
                <li>Configure the webhooks for your phone number</li>
                <li>Set HTTP POST as the request method</li>
                <li>Save your changes</li>
              </ol>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================
File: src/app/(auth)/dashboard/settings/page.tsx
================
import { auth } from '@clerk/nextjs/server'
import { redirect } from "next/navigation";
import { Metadata } from 'next'

export const metadata: Metadata = {
  title: "Settings",
  description: "Manage your account settings and preferences",
}

export default async function SettingsPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/sign-in");
  }

  return (
    <div>
      <h2 className="text-3xl font-bold tracking-tight">Settings</h2>
      <p className="text-muted-foreground">Manage your account and preferences</p>
    </div>
  );
}

================
File: src/app/(auth)/dashboard/layout.tsx
================
// src/app/(auth)/dashboard/layout.tsx
import { UserButton } from "@clerk/nextjs";
import { 
  Menu,
  Home,
  MessageCircle,
  Settings,
  Plug,
  BarChart,
  Code
} from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { QueryProvider } from "@/components/providers/query-provider";

const navigation = [
  { 
    name: 'Overview', 
    href: '/dashboard',
    icon: Home
  },
  { 
    name: 'Communications', 
    href: '/dashboard/communications',
    icon: MessageCircle,
    children: [
      { name: 'Email', href: '/dashboard/communications/email' },
      { name: 'Calls', href: '/dashboard/communications/calls' },
      { name: 'SMS', href: '/dashboard/communications/sms' }
    ]
  },
  { 
    name: 'Integrations', 
    href: '/dashboard/integrations',
    icon: Plug,
    children: [
      { name: 'Gmail Setup', href: '/dashboard/integrations/gmail' },
      { name: 'Twilio Setup', href: '/dashboard/integrations/twilio' }
    ]
  },
  { 
    name: 'Analytics', 
    href: '/dashboard/analytics',
    icon: BarChart
  },
  { 
    name: 'API', 
    href: '/dashboard/api',
    icon: Code
  },
  { 
    name: 'Settings', 
    href: '/dashboard/settings',
    icon: Settings 
  }
];

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <QueryProvider>
      <div className="min-h-screen bg-gray-50">
        {/* Top Navigation Bar */}
        <header className="border-b bg-white">
          <div className="flex h-16 items-center justify-between px-4 sm:px-6 lg:px-8">
            <div className="flex items-center gap-4">
              <Sheet>
                <SheetTrigger asChild>
                  <Button variant="ghost" size="icon" className="lg:hidden">
                    <Menu className="h-6 w-6" />
                  </Button>
                </SheetTrigger>
                <SheetContent side="left" className="w-64">
                  <nav className="flex flex-col gap-4">
                    {navigation.map((item) => (
                      <Link
                        key={item.name}
                        href={item.href}
                        className="flex items-center gap-2 text-sm font-medium hover:text-blue-500 transition-colors"
                      >
                        {item.icon && <item.icon className="h-4 w-4" />}
                        {item.name}
                      </Link>
                    ))}
                  </nav>
                </SheetContent>
              </Sheet>
              <Link href="/dashboard" className="text-xl font-bold">
                Senate Insights
              </Link>
            </div>
            <div className="flex items-center gap-4">
              <UserButton afterSignOutUrl="/" />
            </div>
          </div>
        </header>

        {/* Main Content Area */}
        <div className="flex">
          {/* Sidebar Navigation (desktop) */}
          <div className="hidden lg:flex h-[calc(100vh-64px)] w-64 flex-col border-r bg-white">
            <nav className="flex-1 space-y-1 px-4 py-4">
              {navigation.map((item) => (
                <div key={item.name}>
                  <Link
                    href={item.href}
                    className="group flex items-center px-2 py-2 text-sm font-medium rounded-md hover:bg-gray-50 hover:text-blue-500 transition-colors"
                  >
                    {item.icon && <item.icon className="h-4 w-4 mr-3" />}
                    {item.name}
                  </Link>
                  {item.children && (
                    <div className="ml-4 space-y-1">
                      {item.children.map((child) => (
                        <Link
                          key={child.name}
                          href={child.href}
                          className="group flex items-center px-2 py-1 text-sm text-gray-600 hover:text-blue-500 transition-colors"
                        >
                          {child.name}
                        </Link>
                      ))}
                    </div>
                  )}
                </div>
              ))}
            </nav>
          </div>

          {/* Main Content */}
          <main className="flex-1 p-4 lg:p-8">
            {children}
          </main>
        </div>
      </div>
    </QueryProvider>
  );
}

================
File: src/app/(auth)/dashboard/page.tsx
================
// src/app/(auth)/dashboard/page.tsx
import { auth } from '@clerk/nextjs/server';
import { redirect } from "next/navigation";
import { prisma } from '@/lib/prisma';
import DashboardContent from '@/components/dashboard/dashboard-content';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/sign-in");
  }

  // Try to find user
  const user = await prisma.user.findUnique({
    where: { id: userId }
  });

  // If no user found, sync first
  if (!user) {
    const syncUrl = `/api/auth/sync?redirect=/dashboard`;
    redirect(syncUrl);
  }

  return (
    <div className="space-y-8">
      <DashboardContent userId={userId} />
    </div>
  );
}

================
File: src/app/api/auth/callback/route.ts
================
import { NextResponse } from 'next/server';
import { gmailClient } from '@/lib/integrations/gmail/client';
import { prisma } from '@/lib/prisma';
import type { UserSettings } from '@/lib/integrations/gmail/types';

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const code = url.searchParams.get('code');
    const error = url.searchParams.get('error');

    console.log('Callback received:', { code, error });

    if (error) {
      console.error('OAuth error:', error);
      return NextResponse.redirect(
        new URL('/dashboard/settings/email?error=' + encodeURIComponent(error), 
        process.env.NEXT_PUBLIC_URL!)
      );
    }

    if (!code) {
      return NextResponse.redirect(
        new URL('/dashboard/settings/email?error=no_code', 
        process.env.NEXT_PUBLIC_URL!)
      );
    }

    // Exchange code for tokens
    const tokens = await gmailClient.getTokens(code);
    console.log('Received tokens');
    
    // Save tokens securely
    const user = await prisma.user.upsert({
      where: { 
        email: 'haloweaveinsights@gmail.com'
      },
      update: {
        settings: {
          gmailTokens: tokens
        } as UserSettings
      },
      create: {
        email: 'haloweaveinsights@gmail.com',
        role: 'ADMIN',
        settings: {
          gmailTokens: tokens
        } as UserSettings
      }
    });

    console.log('Updated user');

    // Set up Gmail credentials
    await gmailClient.setCredentials(tokens);

    // Initial sync of recent emails
    const { syncRecentEmails } = await import('@/lib/integrations/gmail/handlers/email');
    await syncRecentEmails(50);

    return NextResponse.redirect(
      new URL('/dashboard/settings/email?success=true', 
      process.env.NEXT_PUBLIC_URL!)
    );
  } catch (error) {
    console.error('Callback error:', error);
    return NextResponse.redirect(
      new URL('/dashboard/settings/email?error=internal_error', 
      process.env.NEXT_PUBLIC_URL!)
    );
  }
}

================
File: src/app/api/auth/sync/route.ts
================
// src/app/api/auth/sync/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth, currentUser } from '@clerk/nextjs/server';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/integrations/utils';

export async function GET(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get Clerk user data
    const clerkUser = await currentUser();
    if (!clerkUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    logger.info('Syncing user', {
      userId,
      email: clerkUser.emailAddresses[0]?.emailAddress,
      action: 'user_sync_start'
    });

    // Get or create user
    const user = await prisma.user.upsert({
      where: { id: userId },
      update: {
        email: clerkUser.emailAddresses[0]?.emailAddress || '',
        name: `${clerkUser.firstName || ''} ${clerkUser.lastName || ''}`.trim(),
      },
      create: {
        id: userId,
        email: clerkUser.emailAddresses[0]?.emailAddress || '',
        name: `${clerkUser.firstName || ''} ${clerkUser.lastName || ''}`.trim(),
        role: 'USER',
        settings: {}
      }
    });

    logger.info('User synced', {
      userId: user.id,
      email: user.email,
      action: 'user_sync_success'
    });

    // Handle redirect if present
    const redirectUrl = new URL(request.url).searchParams.get('redirect');
    if (redirectUrl) {
      return NextResponse.redirect(new URL(redirectUrl, process.env.NEXT_PUBLIC_URL));
    }

    return NextResponse.json({ success: true, user });
  } catch (error) {
    logger.error('User sync failed', error);
    
    // Return more detailed error for debugging
    return NextResponse.json(
      { 
        error: 'Sync failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

// Also handle POST for API calls
export { GET as POST };

================
File: src/app/api/communications/route.ts
================
// src/app/api/communications/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: Request) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const type = searchParams.get('type');

    const communications = await prisma.communication.findMany({
      where: {
        userId,
        ...(type && type !== 'all' ? { type } : {}),
      },
      orderBy: {
        createdAt: 'desc'
      },
      take: 10,
      include: {
        analysis: true
      }
    });

    return NextResponse.json(communications);
  } catch (error) {
    console.error('Failed to fetch communications:', error);
    return NextResponse.json(
      { error: 'Failed to fetch communications' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/integrations/gmail/auth/route.ts
================
// src/app/api/integrations/gmail/auth/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { gmailClient } from '@/lib/integrations/gmail/client';
import { logger } from '@/lib/integrations/utils';

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    logger.info('Starting Gmail auth', { userId });

    const authUrl = gmailClient.getAuthUrl();
    logger.info('Generated auth URL', { authUrl });

    return NextResponse.json({ authUrl });
  } catch (error) {
    logger.error('Gmail auth error', error);
    return NextResponse.json(
      { error: 'Failed to start Gmail auth' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/integrations/gmail/callback/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { gmailClient } from '@/lib/integrations/gmail/client';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/integrations/utils';
import { IntegrationError } from '@/lib/integrations/errors';
import { validateGmailScope } from '@/lib/integrations/gmail/types';

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      throw new IntegrationError('Unauthorized', 'UNAUTHORIZED', 401);
    }

    const searchParams = new URL(req.url).searchParams;
    const code = searchParams.get('code');
    const error = searchParams.get('error');
    
    if (error) {
      logger.error('Google OAuth error', { error });
      return NextResponse.redirect(
        `${process.env.NEXT_PUBLIC_URL}/dashboard/integrations/gmail?error=${error}`
      );
    }

    if (!code) {
      throw new IntegrationError('No authorization code', 'INVALID_REQUEST', 400);
    }

    // Get tokens from Google
    const tokens = await gmailClient.getTokens(code);
    logger.info('Received Gmail tokens', { userId, action: 'gmail_callback' });

    // Store tokens as parsed object, not string
    const user = await prisma.user.upsert({
      where: { id: userId },
      update: {
        settings: {
          gmailTokens: tokens  // Store directly as object
        }
      },
      create: {
        id: userId,
        email: '',
        settings: {
          gmailTokens: tokens  // Store directly as object
        }
      }
    });

    logger.info('Updated user settings', { userId: user.id });

    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_URL}/dashboard/integrations/gmail?success=true`
    );
  } catch (error) {
    logger.error('Gmail callback error', error);
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_URL}/dashboard/integrations/gmail?error=${encodeURIComponent(error instanceof Error ? error.message : 'auth_failed')}`
    );
  }
}

================
File: src/app/api/integrations/gmail/disconnect/route.ts
================
// src/app/api/integrations/gmail/disconnect/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/integrations/utils';

export async function POST() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get current user
    const user = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Update user settings, preserving other settings
    await prisma.user.update({
      where: { id: userId },
      data: {
        settings: {
          ...user.settings,
          gmailTokens: null
        }
      }
    });

    logger.info('Gmail disconnected', { userId });

    return NextResponse.json({ success: true });
  } catch (error) {
    logger.error('Gmail disconnect failed', error);
    return NextResponse.json(
      { error: 'Failed to disconnect', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/integrations/gmail/sync/route.ts
================
// src/app/api/integrations/gmail/sync/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { gmailClient } from '@/lib/integrations/gmail/client';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/integrations/utils';
import { google } from 'googleapis';

export async function POST() {
    try {
      const { userId } = await auth();
      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
  
      logger.info('Starting email sync', { userId });
  
      // Check if Gmail is connected
      const user = await prisma.user.findUnique({
        where: { id: userId }
      });
  
      if (!user?.settings || !(user.settings as any).gmailTokens) {
        logger.error('Gmail not connected', { userId });
        return NextResponse.json(
          { error: 'Gmail not connected. Please connect Gmail first.' },
          { status: 400 }
        );
      }
  
      // Add more detailed logging
      logger.info('Fetching messages', { 
        userId,
        hasTokens: !!(user.settings as any).gmailTokens 
      });
  
      // Get messages
      const messages = await gmailClient.listEmails(userId);
      let processedCount = 0;
  
      logger.info('Processing messages', { 
        userId,
        messageCount: messages.length 
      });
  
      for (const message of messages) {
        const content = await gmailClient.getEmailContent(userId, message.id);
        await prisma.communication.create({
          data: {
            type: 'EMAIL',
            direction: 'INBOUND',
            status: 'PENDING',
            rawContent: content.content,
            processedContent: content.content,
            metadata: message as unknown as Record<string, any>,
            sourceId: message.id,
            source: 'GMAIL',
            participants: [message.from.email, message.to.email],
            userId
          }
        });
        processedCount++;
        logger.info('Processed message', { 
          userId,
          messageId: message.id,
          processedCount 
        });
      }
  
      logger.info('Sync complete', {
        userId,
        processedCount,
        totalMessages: messages.length
      });
  
      return NextResponse.json({
        success: true,
        processed: processedCount,
        total: messages.length
      });
    } catch (error) {
      logger.error('Email sync failed', error);
      return NextResponse.json(
        { error: 'Sync failed', details: error instanceof Error ? error.message : 'Unknown error' },
        { status: 500 }
      );
    }
  }

================
File: src/app/api/test/route.ts
================
// src/app/api/test/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { gmailClient } from '@/lib/integrations/gmail/client';
import { logger } from '@/lib/integrations/utils';

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Test Gmail Connection
    const gmailStatus = await gmailClient.testConnection(userId);

    // For now, return static Twilio status until we implement it
    const twilioStatus = {
      connected: false,
      message: 'Not implemented yet'
    };

    return NextResponse.json({
      gmail: gmailStatus,
      twilio: twilioStatus,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Integration test failed', error);
    return NextResponse.json(
      { error: 'Test failed', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/test-call/route.ts
================
import { NextResponse } from 'next/server';
import twilio from 'twilio';

export async function GET(req: Request) {
  console.log('Starting test call...');

  const accountSid = process.env.TWILIO_ACCOUNT_SID!;
  const authToken = process.env.TWILIO_AUTH_TOKEN!;

  console.log('Account SID:', accountSid);
  console.log('Auth Token:', authToken);

  const twilioClient = twilio(accountSid, authToken);

  console.log('twilioClient:', twilioClient);
  console.log('twilioClient.calls:', twilioClient.calls);

  try {
    const call = await twilioClient.calls.create({
      url: 'http://demo.twilio.com/docs/voice.xml',
      to: '+919886639809', // Replace with the phone number you want to call
      from: process.env.TWILIO_PHONE_NUMBER!, // Your Twilio phone number
    });

    console.log('Call created:', call.sid);

    return NextResponse.json({
      success: true,
      callSid: call.sid,
    });
  } catch (error) {
    console.error('Call error:', error);
    return NextResponse.json(
      {
        error: (error as Error).message,
        stack:
          process.env.NODE_ENV === 'development'
            ? (error as Error).stack
            : undefined,
      },
      {
        status: 500,
      }
    );
  }
}

================
File: src/app/api/webhooks/gmail/route.ts
================
import { NextResponse } from 'next/server';
import { handleHistoryUpdate } from '@/lib/integrations/gmail/handlers/email';
import { prisma } from '@/lib/prisma';
import { gmailClient } from '@/lib/integrations/gmail/client';
import type { UserSettings } from '@/lib/integrations/gmail/types';

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const data = JSON.parse(Buffer.from(body.message.data, 'base64').toString());
    const historyId = data.historyId;
    
    const user = await prisma.user.findFirstOrThrow({
      where: { 
        email: 'haloweaveinsights@gmail.com'
      }
    });

    const settings = user.settings as UserSettings;
    const tokens = settings.gmailTokens;
    
    if (!tokens) {
      throw new Error('No Gmail tokens found');
    }

    await gmailClient.setCredentials(tokens);
    await handleHistoryUpdate(historyId);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/webhooks/twilio/sms/route.ts
================
// src/app/api/webhooks/twilio/sms/route.ts

import { twilioProcessor } from '@/lib/integrations/twilio/handlers/processor';
import { logger, handleIntegrationError } from '@/lib/integrations/utils';
import type { TwilioSMSWebhookPayload } from '@/lib/integrations/twilio/types';
import { prisma } from '@/lib/prisma';

export async function POST(req: Request) {
  logger.info('Received Twilio SMS webhook', { source: 'TWILIO', action: 'sms_webhook' });

  try {
    const url = `${process.env.NEXT_PUBLIC_URL}/api/webhooks/twilio/sms`;

    // Validate webhook
    const isValid = await twilioProcessor.validateWebhook(req.clone(), url);
    if (!isValid) {
      logger.error('Invalid Twilio signature', new Error('Signature validation failed'), {
        source: 'TWILIO',
        action: 'webhook_validation',
      });
      return new Response('Invalid signature', { status: 403 });
    }

    // Process webhook payload
    const body = await req.formData();
    const payload = Object.fromEntries(body.entries()) as TwilioSMSWebhookPayload;

    logger.info('Processing SMS webhook', {
      source: 'TWILIO',
      action: 'process_sms',
      details: {
        from: payload.From,
        to: payload.To,
        body: payload.Body,
      },
    });

    // Save the SMS content to the database
    const communication = await prisma.communication.create({
      data: {
        type: 'SMS',
        direction: 'INBOUND',
        rawContent: payload.Body,
        processedContent: payload.Body,
        metadata: {
          source: 'TWILIO',
          sourceId: payload.MessageSid,
          from: payload.From,
          to: payload.To,
        },
        sourceId: payload.MessageSid,
        source: 'TWILIO',
        status: 'PROCESSED',
        participants: [payload.From, payload.To],
        userId: 'default-user-id', // Replace with actual user ID logic
      },
    });

    // Run AI analysis on the message body
    await runAIAnalysis(communication.id, payload.Body);

    // Optional: Send an automatic reply
    const twiml = `
      <Response>
        <Message>Your message has been received. Thank you!</Message>
      </Response>
    `;
    return new Response(twiml, {
      headers: { 'Content-Type': 'text/xml' },
    });
  } catch (error) {
    const integrationError = handleIntegrationError(error, 'TWILIO', 'sms_webhook');
    logger.error('Error processing SMS webhook', integrationError, {
      source: 'TWILIO',
      action: 'sms_webhook_error',
    });

    // Respond with an empty TwiML to Twilio
    const twiml = `<Response></Response>`;
    return new Response(twiml, {
      headers: { 'Content-Type': 'text/xml' },
    });
  }
}

// Placeholder for AI analysis function
async function runAIAnalysis(messageId: string, messageBody: string) {
  // Implement your AI analysis logic here
  logger.info('Running AI analysis on SMS', { messageId, messageBody });
}

================
File: src/app/api/webhooks/twilio/test/route.ts
================
import { NextResponse } from 'next/server';

export async function POST(req: Request) {
  try {
    const body = await req.formData();
    console.log('Received webhook:', Object.fromEntries(body.entries()));
    
    return NextResponse.json({ 
      received: true, 
      timestamp: new Date().toISOString() 
    });
  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json(
      { error: 'Processing failed' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/webhooks/twilio/voice/recording/route.ts
================
// src/app/api/webhooks/twilio/voice/recording/route.ts

import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/integrations/utils';

export async function POST(req: Request) {
  try {
    const body = await req.formData();
    const payload = Object.fromEntries(body.entries());

    const {
      CallSid,
      RecordingSid,
      RecordingUrl,
      RecordingDuration,
      From,
      To,
    } = payload as any;

    logger.info('Recording completed', {
      CallSid,
      RecordingSid,
      RecordingUrl,
      RecordingDuration,
    });

    // Save the recording details to the database
    await prisma.communication.create({
      data: {
        type: 'CALL',
        direction: 'INBOUND',
        rawContent: RecordingUrl,
        metadata: {
          source: 'TWILIO',
          sourceId: CallSid,
          recordingSid: RecordingSid,
          recordingUrl: RecordingUrl,
          recordingDuration: RecordingDuration,
          from: From,
          to: To,
        },
        sourceId: CallSid,
        source: 'TWILIO',
        status: 'PROCESSING',
        participants: [From, To],
        userId: 'default-user-id', // Replace with actual user ID logic
      },
    });

    // Return empty TwiML response
    const twiml = `<Response></Response>`;
    return new Response(twiml, {
      headers: { 'Content-Type': 'text/xml' },
    });
  } catch (error) {
    logger.error('Error handling recording completion', error);
    return new Response('Error processing recording', { status: 500 });
  }
}

================
File: src/app/api/webhooks/twilio/voice/transcription/route.ts
================
// src/app/api/webhooks/twilio/voice/transcription/route.ts

import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/integrations/utils';

export async function POST(req: Request) {
  try {
    const body = await req.formData();
    const payload = Object.fromEntries(body.entries());

    const {
      CallSid,
      RecordingSid,
      TranscriptionText,
      From,
      To,
    } = payload as any;

    logger.info('Transcription received', {
      CallSid,
      RecordingSid,
      TranscriptionText,
    });

    // Update the communication record with the transcription
    await prisma.communication.updateMany({
      where: {
        sourceId: CallSid,
        'metadata.recordingSid': RecordingSid,
      },
      data: {
        processedContent: TranscriptionText,
        status: 'PROCESSED',
      },
    });

    // Run AI analysis on the transcript
    // (Assuming you have a function `runAIAnalysis`)
    await runAIAnalysis(CallSid, TranscriptionText);

    // Return empty TwiML response
    const twiml = `<Response></Response>`;
    return new Response(twiml, {
      headers: { 'Content-Type': 'text/xml' },
    });
  } catch (error) {
    logger.error('Error handling transcription', error);
    return new Response('Error processing transcription', { status: 500 });
  }
}

// Placeholder for AI analysis function
async function runAIAnalysis(callSid: string, transcript: string) {
  // Implement your AI analysis logic here
  logger.info('Running AI analysis', { callSid, transcript });
}

================
File: src/app/api/webhooks/twilio/voice/route.ts
================
import { NextResponse } from 'next/server';
import { validateRequest } from 'twilio';
import { handleIncomingCall } from '@/lib/integrations/twilio/handlers/call';
import { TwilioCallWebhookPayload } from '@/lib/integrations/twilio/types';

export async function POST(req: Request) {
  try {
    const body = await req.formData();
    const payload = Object.fromEntries(body.entries());
    const twilioSignature = req.headers.get('x-twilio-signature') || '';
    
    // Validate the request is from Twilio
    const url = process.env.VERCEL_URL 
      ? `https://${process.env.VERCEL_URL}/api/webhooks/twilio/voice`
      : 'http://localhost:3000/api/webhooks/twilio/voice';

    const isValid = validateRequest(
      process.env.TWILIO_AUTH_TOKEN!,
      twilioSignature,
      url,
      payload
    );

    if (!isValid) {
      return NextResponse.json(
        { error: 'Invalid signature' },
        { status: 403 }
      );
    }

    const communication = await handleIncomingCall(payload as unknown as TwilioCallWebhookPayload);
    
    // Return TwiML to record the call
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
      <Response>
        <Say>This call will be recorded for quality assurance.</Say>
        <Record transcribe="true" maxLength="3600"/>
      </Response>`;
    
    return new Response(twiml, {
      headers: { 'Content-Type': 'text/xml' }
    });
  } catch (error) {
    console.error('Voice webhook error:', error);
    return NextResponse.json(
      { error: 'Processing failed' },
      { status: 500 }
    );
  }
}

================
File: src/app/dashboard/settings/email/layout.tsx
================
import { ErrorBoundary } from '@/components/error-boundary';

export default function EmailSettingsLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <ErrorBoundary>{children}</ErrorBoundary>;
}

================
File: src/app/dashboard/settings/email/page.tsx
================
'use client';

import { useState, useEffect } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { useRouter, useSearchParams } from 'next/navigation';

interface EmailStats {
  count: number;
  messagesFound: number;
  emailsProcessed: number;
}

export default function GmailSettingsPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [stats, setStats] = useState<EmailStats | null>(null);

  const handleConnect = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch('/api/auth/gmail');
      const data = await response.json();
      
      if (data.error) {
        setError(data.error);
        return;
      }

      if (data.authUrl) {
        window.location.href = data.authUrl;
      }
    } catch (err) {
      setError('Failed to initiate Gmail connection');
      console.error('Connection error:', err);
    } finally {
      setLoading(false);
    }
  };

  const fetchStats = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/emails');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (data.error) {
        throw new Error(data.error);
      }
      setStats({
        count: data.count || 0,
        messagesFound: data.debug?.messagesFound || 0,
        emailsProcessed: data.debug?.emailsProcessed || 0
      });
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch email stats');
      console.error('Stats error:', err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Check URL parameters for OAuth response
    const success = searchParams.get('success');
    const oauthError = searchParams.get('error');

    if (oauthError) {
      setError(decodeURIComponent(oauthError));
    } else if (success) {
      fetchStats().catch(console.error);
    } else {
      // Initial load
      fetchStats().catch(console.error);
    }
  }, [searchParams]);

  return (
    <div className="container mx-auto p-4">
      <Card className="p-6">
        <h1 className="text-2xl font-bold mb-4">Gmail Integration Settings</h1>
        
        <div className="space-y-4">
          <Button 
            onClick={handleConnect} 
            disabled={loading}
            className="mb-4"
          >
            {loading ? 'Processing...' : 'Connect Gmail Account'}
          </Button>

          {error && (
            <div className="bg-red-50 text-red-500 p-4 rounded-md mb-4">
              {error}
            </div>
          )}

          {stats && (
            <div className="space-y-2 mt-6">
              <h2 className="text-xl font-semibold">Email Statistics</h2>
              <div className="grid grid-cols-3 gap-4">
                <Card className="p-4">
                  <div className="text-sm text-gray-600">Total Emails</div>
                  <div className="text-2xl font-bold">{stats.count}</div>
                </Card>
                <Card className="p-4">
                  <div className="text-sm text-gray-600">Messages Found</div>
                  <div className="text-2xl font-bold">{stats.messagesFound}</div>
                </Card>
                <Card className="p-4">
                  <div className="text-sm text-gray-600">Processed</div>
                  <div className="text-2xl font-bold">{stats.emailsProcessed}</div>
                </Card>
              </div>
            </div>
          )}

          <div className="mt-4">
            <Button 
              variant="outline" 
              onClick={() => fetchStats()}
              disabled={loading}
              className="mt-4"
            >
              {loading ? 'Refreshing...' : 'Refresh Stats'}
            </Button>
          </div>
        </div>
      </Card>
    </div>
  );
}

================
File: src/app/sign-in/[[...sign-in]]/page.tsx
================
import { SignIn } from '@clerk/nextjs'
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Sign In',
  description: 'Sign in to your account',
}

export default function SignInPage(): JSX.Element {
  return (
    <div className="flex min-h-screen items-center justify-center">
      <SignIn 
        appearance={{
          elements: {
            rootBox: "mx-auto",
            card: "bg-white"
          }
        }} 
      />
    </div>
  );
}

================
File: src/app/sign-up/[[...sign-up]]/page.tsx
================
import { SignUp } from '@clerk/nextjs'
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Sign Up',
  description: 'Create your account',
}

export default function SignUpPage(): JSX.Element {
  return (
    <div className="flex min-h-screen items-center justify-center">
      <SignUp 
        appearance={{
          elements: {
            rootBox: "mx-auto",
            card: "bg-white"
          }
        }} 
      />
    </div>
  );
}

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/app/layout.tsx
================
// src/app/layout.tsx
import { ClerkProvider } from '@clerk/nextjs';
import { Inter } from 'next/font/google';
import { Metadata } from 'next';
import { siteConfig } from '@/config/metadata';
import { Toaster } from 'sonner';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: {
    default: siteConfig.name,
    template: `%s | ${siteConfig.name}`,
  },
  description: siteConfig.description,
  keywords: [
    'Communication Analytics',
    'AI Analytics',
    'Business Intelligence',
    'Customer Insights',
    'Data Analytics',
    'Communication Platform',
  ],
  authors: [
    {
      name: siteConfig.creator,
      url: siteConfig.url,
    },
  ],
  creator: siteConfig.creator,
  openGraph: {
    type: 'website',
    locale: 'en_US',
    url: siteConfig.url,
    title: siteConfig.name,
    description: siteConfig.description,
    siteName: siteConfig.name,
    images: [
      {
        url: siteConfig.ogImage,
        width: 1200,
        height: 630,
        alt: siteConfig.name,
      },
    ],
  },
  twitter: {
    card: 'summary_large_image',
    title: siteConfig.name,
    description: siteConfig.description,
    images: [siteConfig.ogImage],
    creator: '@senateinsights',
  },
  icons: {
    icon: '/favicon.ico',
    shortcut: '/favicon-16x16.png',
    apple: '/apple-touch-icon.png',
  },
  manifest: '/site.webmanifest',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>
          {children}
          <Toaster />
        </body>
      </html>
    </ClerkProvider>
  );
}

================
File: src/app/loading.tsx
================
export default function Loading() {
    return (
      <div className="flex h-screen w-screen items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    )
  }

================
File: src/app/not-found.tsx
================
import Link from 'next/link'
import { Metadata } from 'next'

export const metadata: Metadata = {
  title: "404: Page Not Found",
  description: "The page you're looking for doesn't exist.",
}

export default function NotFound() {
  return (
    <div className="flex min-h-screen flex-col items-center justify-center">
      <h1 className="text-4xl font-bold">404</h1>
      <p className="mt-2 text-lg text-gray-600">Page not found</p>
      <Link 
        href="/"
        className="mt-4 text-blue-500 hover:text-blue-600"
      >
        Return Home
      </Link>
    </div>
  )
}

================
File: src/app/page.tsx
================
import { SignedIn, SignedOut } from "@clerk/nextjs";
import Link from "next/link";
import { Metadata } from 'next'
import { siteConfig } from '@/config/metadata'

export const metadata: Metadata = {
  title: "Home",
  description: siteConfig.description,
}

export default function Home() {
  return (
    <div className="flex min-h-[calc(100vh-73px)] flex-col items-center justify-center p-8">
      <div className="max-w-3xl text-center">
        <h1 className="text-6xl font-bold mb-6">
          Senate Insights
        </h1>
        <p className="text-xl text-gray-600 mb-8">
          Powerful communication analytics platform for modern businesses
        </p>
        
        <SignedOut>
          <div className="space-x-4">
            <Link 
              href="/sign-up" 
              className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Get Started
            </Link>
            <Link 
              href="/sign-in" 
              className="border border-gray-300 hover:border-gray-400 text-gray-700 font-bold py-3 px-6 rounded-lg"
            >
              Sign In
            </Link>
          </div>
        </SignedOut>

        <SignedIn>
          <Link 
            href="/dashboard" 
            className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg"
          >
            Go to Dashboard
          </Link>
        </SignedIn>
      </div>

      {/* Feature Highlights */}
      <div className="mt-20 grid grid-cols-1 md:grid-cols-3 gap-8 max-w-6xl w-full">
        <div className="p-6 border rounded-lg">
          <h3 className="text-xl font-bold mb-2">Real-time Analytics</h3>
          <p className="text-gray-600">Monitor and analyze your communications in real-time</p>
        </div>
        <div className="p-6 border rounded-lg">
          <h3 className="text-xl font-bold mb-2">AI-Powered Insights</h3>
          <p className="text-gray-600">Get intelligent insights with our advanced AI analysis</p>
        </div>
        <div className="p-6 border rounded-lg">
          <h3 className="text-xl font-bold mb-2">Multi-channel Support</h3>
          <p className="text-gray-600">Integrate calls, SMS, and emails in one platform</p>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/dashboard/communications/communications-dashboard.tsx
================
// src/components/dashboard/communications/communications-dashboard.tsx
"use client";

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Loader2, Mail, Phone, MessageSquare } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';

// Add type export
export type CommunicationItem = {
  id: string;
  type: 'EMAIL' | 'CALL' | 'SMS';
  direction: 'INBOUND' | 'OUTBOUND';
  metadata: any;
  status: string;
  createdAt: string;
  analysis?: {
    sentiment: {
      score: number;
      label: string;
    };
    categories: string[];
    summary?: string;
  };
};

// Named export for CommunicationsDashboard
export function CommunicationsDashboard() {
  const [activeTab, setActiveTab] = useState('all');
  const [isSyncing, setIsSyncing] = useState(false);

  const { data: communications, refetch, isLoading } = useQuery({
    queryKey: ['communications', activeTab],
    queryFn: async () => {
      const response = await fetch(`/api/communications?type=${activeTab}`);
      if (!response.ok) throw new Error('Failed to fetch communications');
      return response.json();
    }
  });

  const handleSync = async () => {
    setIsSyncing(true);
    try {
      await Promise.all([
        fetch('/api/integrations/gmail/sync', { method: 'POST' }),
        fetch('/api/integrations/twilio/sync', { method: 'POST' })
      ]);
      await refetch();
    } finally {
      setIsSyncing(false);
    }
  };

  const getIconForType = (type: string) => {
    switch (type) {
      case 'EMAIL': return <Mail className="h-4 w-4" />;
      case 'CALL': return <Phone className="h-4 w-4" />;
      case 'SMS': return <MessageSquare className="h-4 w-4" />;
      default: return null;
    }
  };

  const getSentimentColor = (score: number) => {
    if (score > 0.5) return 'text-green-500';
    if (score < -0.5) return 'text-red-500';
    return 'text-yellow-500';
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">Communications Dashboard</h2>
        <Button 
          onClick={handleSync} 
          disabled={isSyncing}
        >
          {isSyncing ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Syncing...
            </>
          ) : 'Sync All'}
        </Button>
      </div>

      <Tabs defaultValue="all" onValueChange={setActiveTab}>
        <TabsList>
          <TabsTrigger value="all">All</TabsTrigger>
          <TabsTrigger value="EMAIL">Emails</TabsTrigger>
          <TabsTrigger value="CALL">Calls</TabsTrigger>
          <TabsTrigger value="SMS">SMS</TabsTrigger>
        </TabsList>

        <TabsContent value={activeTab}>
          <Card>
            <CardHeader>
              <CardTitle>Recent Communications</CardTitle>
            </CardHeader>
            <CardContent>
              {isLoading ? (
                <div className="flex justify-center p-4">
                  <Loader2 className="h-6 w-6 animate-spin" />
                </div>
              ) : (
                <div className="space-y-4">
                  {communications?.map((item: CommunicationItem) => (
                    <div
                      key={item.id}
                      className="p-4 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors"
                    >
                      <div className="flex justify-between items-start mb-2">
                        <div className="flex items-center gap-2">
                          {getIconForType(item.type)}
                          <span className="font-medium">
                            {item.metadata.subject || item.metadata.from}
                          </span>
                        </div>
                        <div className="text-sm text-gray-500">
                          {formatDistanceToNow(new Date(item.createdAt), { addSuffix: true })}
                        </div>
                      </div>
                      
                      <div className="text-sm text-gray-600 mb-2">
                        From: {item.metadata.from.email || item.metadata.from}
                      </div>
                      
                      {item.analysis && (
                        <div className="mt-2 text-sm">
                          <div className="flex gap-2">
                            <span className={getSentimentColor(item.analysis.sentiment.score)}>
                              {item.analysis.sentiment.label}
                            </span>
                            {item.analysis.categories.map((category, index) => (
                              <span
                                key={index}
                                className="bg-gray-100 text-gray-700 px-2 py-0.5 rounded-full text-xs"
                              >
                                {category}
                              </span>
                            ))}
                          </div>
                          {item.analysis.summary && (
                            <p className="mt-1 text-gray-700">{item.analysis.summary}</p>
                          )}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}

// Default export for flexibility
export default CommunicationsDashboard;

================
File: src/components/dashboard/integrations/integrations-status.tsx
================
// src/components/dashboard/integrations/integrations-status.tsx
"use client";

import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Loader2, CheckCircle, XCircle } from 'lucide-react';

// Named export for IntegrationsStatus
export function IntegrationsStatus() {
  const { data, isLoading } = useQuery({
    queryKey: ['integrations-status'],
    queryFn: async () => {
      const response = await fetch('/api/test');
      if (!response.ok) throw new Error('Failed to fetch status');
      return response.json();
    },
    refetchInterval: 60000 // Check every minute
  });

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Integration Status</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-center p-4">
            <Loader2 className="h-6 w-6 animate-spin" />
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Integration Status</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {/* Gmail Integration Status */}
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <span>Gmail Integration</span>
              {data?.gmail.connected ? (
                <Badge variant="default">
                  <CheckCircle className="h-4 w-4 mr-1" />
                  Connected
                </Badge>
              ) : (
                <Badge variant="destructive">
                  <XCircle className="h-4 w-4 mr-1" />
                  Disconnected
                </Badge>
              )}
            </div>
            {data?.gmail.lastSync && (
              <span className="text-sm text-gray-500">
                Last synced: {new Date(data.gmail.lastSync).toLocaleString()}
              </span>
            )}
          </div>

          {/* Twilio Integration Status */}
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <span>Twilio Integration</span>
              {data?.twilio.connected ? (
                <Badge variant="default">
                  <CheckCircle className="h-4 w-4 mr-1" />
                  Connected
                </Badge>
              ) : (
                <Badge variant="destructive">
                  <XCircle className="h-4 w-4 mr-1" />
                  Disconnected
                </Badge>
              )}
            </div>
            {data?.twilio.lastWebhook && (
              <span className="text-sm text-gray-500">
                Last webhook: {new Date(data.twilio.lastWebhook).toLocaleString()}
              </span>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

// Default export for flexibility
export default IntegrationsStatus;

================
File: src/components/dashboard/dashboard-content.tsx
================
// src/components/dashboard/dashboard-content.tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { MessageCircle, Activity, Users, BarChart } from "lucide-react";
import { IntegrationsStatus } from "./integrations/integrations-status";
import CommunicationsDashboard from "./communications/communications-dashboard";

// Named export for DashboardContent
export function DashboardContent({ userId }: { userId: string }) {
  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">
          Welcome to Dashboard
        </h2>
        <p className="text-muted-foreground">Your communication analytics overview</p>
      </div>

      <IntegrationsStatus />

      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Communications</CardTitle>
            <MessageCircle className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">1,284</div>
            <p className="text-xs text-muted-foreground">+20.1% from last month</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Average Response Time</CardTitle>
            <Activity className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">2.4h</div>
            <p className="text-xs text-muted-foreground">-12% from last month</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Users</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">573</div>
            <p className="text-xs text-muted-foreground">+4.3% from last month</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Sentiment Score</CardTitle>
            <BarChart className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">8.2</div>
            <p className="text-xs text-muted-foreground">+0.3 from last month</p>
          </CardContent>
        </Card>
      </div>

      {/* Dynamic Stats Section */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-7">
        <Card className="col-span-4">
          <CardHeader>
            <CardTitle>Communication Volume</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-[200px] flex items-center justify-center border-2 border-dashed rounded-lg">
              Chart placeholder
            </div>
          </CardContent>
        </Card>

        <Card className="col-span-3">
          <CardHeader>
            <CardTitle>Recent Activity</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-[200px] flex items-center justify-center border-2 border-dashed rounded-lg">
              Activity feed placeholder
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Communications Dashboard */}
      <div className="mt-8">
        <CommunicationsDashboard />
      </div>
    </div>
  );
}

// Default export for flexibility
export default DashboardContent;

================
File: src/components/dashboard/user-greeting.tsx
================
'use client'
import { useUser } from '@clerk/nextjs'

export default function UserGreeting() {
  const { isLoaded, user } = useUser()

  if (!isLoaded) {
    return <div>Loading...</div>
  }

  return (
    <h2 className="text-3xl font-bold tracking-tight">
      Welcome, {user?.firstName || 'User'}
    </h2>
  );
}

================
File: src/components/dashboard/user-info.tsx
================
'use client'
import { useAuth, useUser } from '@clerk/nextjs'

export default function UserInfo() {
  const { isLoaded: authLoaded, userId, sessionId } = useAuth()
  const { isLoaded: userLoaded, isSignedIn, user } = useUser()

  if (!authLoaded || !userLoaded) {
    return <div>Loading...</div>
  }

  if (!isSignedIn) {
    return null
  }

  return (
    <div className="p-4 bg-white rounded-lg shadow">
      <h3 className="font-medium">User Information</h3>
      <div className="mt-2 space-y-2 text-sm">
        <p>User ID: {userId}</p>
        <p>Session: {sessionId}</p>
        <p>Name: {user.firstName} {user.lastName}</p>
        <p>Email: {user.primaryEmailAddress?.emailAddress}</p>
      </div>
    </div>
  )
}

================
File: src/components/dashboard/user-welcome.tsx
================
'use client'
import { useUser } from '@clerk/nextjs'

export default function UserWelcome() {
  const { isLoaded, isSignedIn, user } = useUser()

  if (!isLoaded || !isSignedIn) {
    return <div>Loading...</div>
  }

  return (
    <div>
      <h2 className="text-3xl font-bold tracking-tight">
        Welcome, {user.firstName || 'User'}
      </h2>
      <p className="text-muted-foreground">Your communication analytics overview</p>
    </div>
  );
}

================
File: src/components/providers/query-provider.tsx
================
"use client"

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'

export function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000, // 1 minute
        refetchOnWindowFocus: false,
      },
    },
  }))

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}

================
File: src/components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: src/components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: src/components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import {
  CheckIcon,
  ChevronRightIcon,
  DotFilledIcon,
} from "@radix-ui/react-icons"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-4 w-4 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: src/components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: src/components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

================
File: src/components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { Cross2Icon } from "@radix-ui/react-icons"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: src/components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: src/components/error-boundary.tsx
================
'use client';

import React from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';

interface Props {
  children: React.ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Component error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <Card className="p-6 m-4">
          <h2 className="text-xl font-bold mb-4">Something went wrong</h2>
          <p className="text-red-500 mb-4">{this.state.error?.message}</p>
          <Button
            onClick={() => this.setState({ hasError: false, error: null })}
          >
            Try again
          </Button>
        </Card>
      );
    }

    return this.props.children;
  }
}

================
File: src/config/metadata.ts
================
export const siteConfig = {
    name: "Senate Insights",
    description: "Powerful communication analytics platform for modern businesses",
    url: "https://senate-insights.com",
    ogImage: "https://senate-insights.com/og.jpg",
    links: {
      twitter: "https://twitter.com/senateinsights",
      github: "https://github.com/haloweavedev/senate-insights",
    },
    creator: "Haloweave",
  }
  
  export type SiteConfig = typeof siteConfig

================
File: src/lib/integrations/gmail/client.ts
================
// src/lib/integrations/gmail/client.ts
import { google } from 'googleapis';
import { prisma } from '@/lib/prisma';
import { IntegrationError } from '../errors';
import { logger, handleIntegrationError, parseEmailAddress } from '../utils';
import { debugLog } from '@/lib/integrations/debug';
import type { GmailTokens, EmailMetadata, EmailContent } from './types';

const SCOPES = [
    'https://www.googleapis.com/auth/gmail.readonly'
  ];

class GmailClient {
  private static instance: GmailClient | null = null;
  private oauth2Client;

  private constructor() {
    const clientId = process.env.GMAIL_CLIENT_ID;
    const clientSecret = process.env.GMAIL_CLIENT_SECRET;
    const redirectUri = `${process.env.NEXT_PUBLIC_URL}/api/integrations/gmail/callback`;

    if (!clientId || !clientSecret) {
      throw new IntegrationError(
        'Missing Gmail credentials',
        'GMAIL_CONFIG_ERROR',
        500
      );
    }

    this.oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
  }

  public static getInstance(): GmailClient {
    if (!GmailClient.instance) {
      GmailClient.instance = new GmailClient();
    }
    return GmailClient.instance;
  }

public getAuthUrl(): string {
    try {
      return this.oauth2Client.generateAuthUrl({
        access_type: 'offline',
        scope: SCOPES,
        prompt: 'consent' // Removed include_granted_scopes
      });
    } catch (error) {
      throw handleIntegrationError(error, 'Gmail', 'getAuthUrl');
    }
  }  

  public async getTokens(code: string): Promise<GmailTokens> {
    try {
      const { tokens } = await this.oauth2Client.getToken(code);
      if (!tokens.refresh_token) {
        throw new IntegrationError(
          'No refresh token received',
          'GMAIL_NO_REFRESH_TOKEN',
          400
        );
      }
      return tokens as GmailTokens;
    } catch (error) {
      throw handleIntegrationError(error, 'Gmail', 'getTokens');
    }
  }

  private async ensureValidToken(userId: string): Promise<void> {
    try {
      const user = await prisma.user.findUnique({ where: { id: userId } });
      debugLog('ensureValidToken - User Data', { 
        userId,
        hasSettings: !!user?.settings,
        settingsContent: user?.settings 
      });
  
      if (!user?.settings) {
        throw new IntegrationError('User not found or no settings', 'USER_NOT_FOUND', 404);
      }
  
      const settings = user.settings as { gmailTokens?: string | GmailTokens };
      // Parse tokens if they're a string
      const tokens = typeof settings.gmailTokens === 'string' 
        ? JSON.parse(settings.gmailTokens) 
        : settings.gmailTokens;
  
      debugLog('ensureValidToken - Tokens', { 
        hasTokens: !!tokens,
        expiryDate: tokens?.expiry_date,
        currentTime: Date.now(),
        timeToExpiry: tokens?.expiry_date ? tokens.expiry_date - Date.now() : null,
        parsedTokens: tokens  // Log the parsed tokens
      });

      // Set credentials with the parsed tokens
      this.oauth2Client.setCredentials(tokens);
  
      if (!tokens.scope || !tokens.scope.includes('https://www.googleapis.com/auth/gmail.readonly')) {
        throw new IntegrationError(
          'Access token does not have the required scopes. Please reconnect your Gmail account.',
          'INSUFFICIENT_SCOPES',
          403
        );
      }
  
      // Check expiry and refresh if needed
      if (tokens.expiry_date && tokens.expiry_date < Date.now() + 5 * 60 * 1000) {
        debugLog('ensureValidToken - Refreshing Token', {
          reason: 'Token expired or expiring soon'
        });
        
        const { credentials } = await this.oauth2Client.refreshAccessToken();
        
        await prisma.user.update({
          where: { id: userId },
          data: { 
            settings: { 
              ...user.settings, 
              gmailTokens: credentials  // Store as object
            } 
          }
        });
  
        this.oauth2Client.setCredentials(credentials);
        
        debugLog('ensureValidToken - Token Refreshed', {
          newExpiryDate: credentials.expiry_date
        });
      }
    } catch (error) {
      debugLog('ensureValidToken - Error', { error });
      throw handleIntegrationError(error, 'Gmail', 'ensureValidToken');
    }
  }

  public async testConnection(userId: string): Promise<{ connected: boolean; lastSync?: string }> {
    try {
      await this.ensureValidToken(userId);
      return { connected: true, lastSync: new Date().toISOString() };
    } catch (error) {
      logger.error('Gmail connection test failed', error);
      return { connected: false };
    }
  }

  public async listEmails(userId: string, maxResults: number = 10): Promise<EmailMetadata[]> {
    try {
      await this.ensureValidToken(userId);
      const gmail = google.gmail({ version: 'v1', auth: this.oauth2Client });
      
      // First, list all messages
      const response = await gmail.users.messages.list({
        userId: 'me',
        maxResults,
        // Remove the 'q' parameter from here and filter in memory
      });
  
      if (!response.data.messages) return [];
  
      const emails = await Promise.all(
        response.data.messages.map(async (msg) => {
          const details = await gmail.users.messages.get({
            userId: 'me',
            id: msg.id!,
            format: 'metadata',
            metadataHeaders: ['From', 'To', 'Subject', 'Date']
          });
  
          const headers = details.data.payload?.headers || [];
          const to = headers.find(h => h.name === 'To')?.value || '';
          
          // Filter here instead of in the API query
          if (!to.includes('haloweaveinsights@gmail.com')) {
            return null;
          }
  
          return {
            id: details.data.id!,
            threadId: details.data.threadId!,
            subject: headers.find(h => h.name === 'Subject')?.value || 'No Subject',
            from: parseEmailAddress(headers.find(h => h.name === 'From')?.value || ''),
            to: parseEmailAddress(to),
            date: headers.find(h => h.name === 'Date')?.value || new Date().toISOString(),
            snippet: details.data.snippet || '',
            labels: details.data.labelIds || []
          };
        })
      );
  
      // Filter out null values and limit to maxResults
      return emails.filter(Boolean).slice(0, maxResults);
    } catch (error) {
      throw handleIntegrationError(error, 'Gmail', 'listEmails');
    }
  }

  public async getEmailContent(userId: string, messageId: string): Promise<EmailContent> {
    try {
      await this.ensureValidToken(userId);
      const gmail = google.gmail({ version: 'v1', auth: this.oauth2Client });
      const message = await gmail.users.messages.get({
        userId: 'me',
        id: messageId,
        format: 'full'
      });

      let content = '';
      const attachments: EmailContent['attachments'] = [];

      if (message.data.payload) {
        const extractText = (part: any): string => {
          if (part.mimeType === 'text/plain' && part.body?.data) {
            return Buffer.from(part.body.data, 'base64').toString();
          }
          if (part.parts) {
            return part.parts.map((p: any) => extractText(p)).filter(Boolean).join('\n');
          }
          return '';
        };

        const processAttachments = (part: any) => {
          if (part.filename && part.body) {
            attachments.push({
              id: part.body.attachmentId || '',
              name: part.filename,
              mimeType: part.mimeType,
              size: part.body.size
            });
          }
          if (part.parts) {
            part.parts.forEach((p: any) => processAttachments(p));
          }
        };

        content = extractText(message.data.payload);
        processAttachments(message.data.payload);
      }

      return {
        id: message.data.id!,
        threadId: message.data.threadId!,
        content: content || message.data.snippet || '',
        snippet: message.data.snippet,
        attachments
      };
    } catch (error) {
      throw handleIntegrationError(error, 'Gmail', 'getEmailContent');
    }
  }
}

// Export the singleton instance
export const gmailClient = GmailClient.getInstance();

================
File: src/lib/integrations/gmail/processor.ts
================
import { prisma } from '@/lib/prisma';
import { GmailClient } from './client';
import type { EmailMetadata, EmailContent } from './types';

export async function processEmail(
  userId: string,
  metadata: EmailMetadata,
  content: EmailContent
) {
  try {
    // Check if already processed
    const existing = await prisma.communication.findFirst({
      where: {
        sourceId: metadata.id,
        source: 'GMAIL'
      }
    });

    if (existing) return null;

    // Store in database
    const communication = await prisma.communication.create({
      data: {
        type: 'EMAIL',
        direction: 'INBOUND',
        status: 'PENDING',
        rawContent: content.content,
        processedContent: '',
        metadata: {
          ...metadata,
          hasAttachments: content.attachments && content.attachments.length > 0,
          attachmentsCount: content.attachments?.length || 0
        },
        sourceId: metadata.id,
        source: 'GMAIL',
        participants: [metadata.from.email, metadata.to.email],
        organizationId: 'default-org',
        userId
      }
    });

    return communication;
  } catch (error) {
    throw await handleIntegrationError(error);
  }
}

export async function syncEmailBatch(
  userId: string,
  maxResults: number = 50
): Promise<{ total: number; new: number }> {
  const client = new GmailClient();
  const emails = await client.listEmails(userId, maxResults);

  const results = await Promise.allSettled(
    emails.map(async (email) => {
      const content = await client.getEmailContent(userId, email.id);
      return processEmail(userId, email, content);
    })
  );

  const processed = results.filter(
    (result): result is PromiseFulfilledResult<any> => 
      result.status === 'fulfilled' && result.value !== null
  );

  return {
    total: emails.length,
    new: processed.length
  };
}

================
File: src/lib/integrations/gmail/types.ts
================
import type { IntegrationTokens } from '../types';

export interface GmailTokens extends IntegrationTokens {
  refresh_token: string;
  expiry_date: number;
  scope: string;
}

export interface EmailMetadata {
  id: string;
  threadId: string;
  subject: string;
  from: { email: string; name?: string };
  to: { email: string; name?: string };
  date: string;
  snippet?: string;
  labels: string[];
}

export interface EmailContent {
  id: string;
  threadId: string;
  content: string;
  snippet?: string;
  attachments?: Array<{
    id: string;
    name: string;
    mimeType: string;
    size?: number;
  }>;
}

export const validateGmailScope = (scope: string): boolean => {
  return scope.includes('https://www.googleapis.com/auth/gmail.readonly');
};

================
File: src/lib/integrations/twilio/handlers/call.ts
================
import { prisma } from '@/lib/prisma';
import { TwilioCallWebhookPayload } from '../types';

export async function handleIncomingCall(payload: TwilioCallWebhookPayload) {
  try {
    const communication = await prisma.communication.create({
      data: {
        type: 'CALL',
        direction: payload.Direction === 'inbound' ? 'INBOUND' : 'OUTBOUND',
        rawContent: payload.RecordingUrl || '',
        processedContent: payload.TranscriptionText,
        metadata: payload,
        sourceId: payload.CallSid,
        source: 'TWILIO',
        status: 'PENDING',
        participants: [payload.From, payload.To],
        // TODO: You'll need to implement logic to determine these
        organizationId: 'default-org-id',
        userId: 'default-user-id',
      },
    });

    return communication;
  } catch (error) {
    console.error('Error handling incoming call:', error);
    throw error;
  }
}

================
File: src/lib/integrations/twilio/handlers/processor.ts
================
// src/lib/integrations/twilio/handlers/processor.ts

import { prisma } from '@/lib/prisma';
import { validateRequest } from 'twilio';
import type { TwilioCallWebhookPayload, TwilioSMSWebhookPayload, TwilioMetadata } from '../types';
import { TwilioError } from '../types';
import type { CommunicationProcessor } from '@/lib/integrations/types';

export class TwilioProcessor implements CommunicationProcessor {
  async validateWebhook(request: Request, url: string): Promise<boolean> {
    try {
      const body = await request.formData();
      const payload = Object.fromEntries(body.entries());
      const twilioSignature = request.headers.get('x-twilio-signature') || '';

      return validateRequest(
        process.env.TWILIO_AUTH_TOKEN!,
        twilioSignature,
        url,
        payload as Record<string, string>
      );
    } catch (error) {
      throw new TwilioError(
        'Failed to validate webhook',
        'WEBHOOK_VALIDATION_FAILED',
        403,
        error
      );
    }
  }

  async processIncoming(
    payload: TwilioCallWebhookPayload | TwilioSMSWebhookPayload,
    userId: string = 'default-user-id'
  ) {
    try {
      const isCall = 'CallSid' in payload;
      const metadata: TwilioMetadata = {
        source: 'TWILIO',
        sourceId: isCall ? payload.CallSid : payload.MessageSid,
        direction: payload.Direction === 'inbound' ? 'INBOUND' : 'OUTBOUND',
        participants: [payload.From, payload.To],
        timestamp: new Date().toISOString(),
        status: isCall ? payload.CallStatus : 'received',
        ...(isCall && {
          duration: payload.Duration,
          mediaUrls: payload.RecordingUrl ? [payload.RecordingUrl] : undefined,
        }),
        ...(!isCall && {
          mediaUrls: payload.NumMedia !== '0' ? [payload.MediaUrl0!] : undefined,
        }),
        raw: payload,
      };

      const communication = await prisma.communication.create({
        data: {
          type: isCall ? 'CALL' : 'SMS',
          direction: metadata.direction,
          rawContent: isCall
            ? payload.RecordingUrl || ''
            : payload.Body,
          processedContent: isCall
            ? payload.TranscriptionText || ''
            : payload.Body,
          metadata,
          sourceId: metadata.sourceId,
          source: 'TWILIO',
          status: 'PENDING',
          participants: metadata.participants,
          organizationId: 'default-org',
          userId,
        },
      });

      return communication;
    } catch (error) {
      throw new TwilioError(
        'Failed to process communication',
        'PROCESSING_FAILED',
        500,
        error
      );
    }
  }
}

export const twilioProcessor = new TwilioProcessor();

================
File: src/lib/integrations/twilio/handlers/sms.ts
================
import { prisma } from '@/lib/prisma';
import { TwilioSMSWebhookPayload } from '../types';

export async function handleIncomingSMS(payload: TwilioSMSWebhookPayload) {
  try {
    const communication = await prisma.communication.create({
      data: {
        type: 'SMS',
        direction: 'INBOUND',
        rawContent: payload.Body,
        metadata: payload,
        sourceId: payload.MessageSid,
        source: 'TWILIO',
        status: 'PENDING',
        participants: [payload.From, payload.To],
        // TODO: You'll need to implement logic to determine these
        organizationId: 'default-org-id',
        userId: 'default-user-id',
      },
    });

    return communication;
  } catch (error) {
    console.error('Error handling incoming SMS:', error);
    throw error;
  }
}

================
File: src/lib/integrations/twilio/sms/route.ts
================
// src/app/api/webhooks/twilio/sms/route.ts

import { NextResponse } from 'next/server';
import { twilioProcessor } from '@/lib/integrations/twilio/handlers/processor';
import { logger, handleIntegrationError } from '@/lib/integrations/utils';
import type { TwilioSMSWebhookPayload } from '@/lib/integrations/twilio/types';

export async function POST(req: Request) {
  logger.info('Received Twilio SMS webhook', { source: 'TWILIO', action: 'sms_webhook' });

  try {
    const url = `${process.env.NEXT_PUBLIC_URL}/api/webhooks/twilio/sms`;

    // Validate webhook
    const isValid = await twilioProcessor.validateWebhook(req.clone(), url);
    if (!isValid) {
      logger.error('Invalid Twilio signature', new Error('Signature validation failed'), {
        source: 'TWILIO',
        action: 'webhook_validation',
      });
      return NextResponse.json({ error: 'Invalid signature' }, { status: 403 });
    }

    // Process webhook payload
    const body = await req.formData();
    const payload = Object.fromEntries(body.entries());

    logger.info('Processing SMS webhook', {
      source: 'TWILIO',
      action: 'process_sms',
      details: {
        from: payload.From,
        to: payload.To,
        hasMedia: payload.NumMedia !== '0',
      },
    });

    const communication = await twilioProcessor.processIncoming(
      payload as TwilioSMSWebhookPayload
    );

    return NextResponse.json({
      success: true,
      id: communication.id,
      status: communication.status,
    });
  } catch (error) {
    const integrationError = handleIntegrationError(error, 'TWILIO', 'sms_webhook');

    return NextResponse.json(
      {
        error: integrationError.message,
        code: integrationError.code,
        details: integrationError.details,
      },
      { status: integrationError.status || 500 }
    );
  }
}

================
File: src/lib/integrations/twilio/voice/route.ts
================
// src/app/api/webhooks/twilio/voice/route.ts

import { NextResponse } from 'next/server';
import { twilioProcessor } from '@/lib/integrations/twilio/handlers/processor';
import { logger, handleIntegrationError } from '@/lib/integrations/utils';
import type { TwilioCallWebhookPayload } from '@/lib/integrations/twilio/types';

export async function POST(req: Request) {
  logger.info('Received Twilio Voice webhook', { source: 'TWILIO', action: 'voice_webhook' });

  try {
    const url = `${process.env.NEXT_PUBLIC_URL}/api/webhooks/twilio/voice`;

    const isValid = await twilioProcessor.validateWebhook(req.clone(), url);
    if (!isValid) {
      logger.error('Invalid Twilio signature', new Error('Signature validation failed'), {
        source: 'TWILIO',
        action: 'webhook_validation',
      });
      return new Response('Invalid signature', { status: 403 });
    }

    // Parse the incoming payload
    const body = await req.formData();
    const payload = Object.fromEntries(body.entries()) as TwilioCallWebhookPayload;

    // Log incoming call details
    logger.info('Processing incoming call', {
      source: 'TWILIO',
      action: 'process_call',
      details: {
        from: payload.From,
        to: payload.To,
      },
    });

    // Generate TwiML to play message and record the call
    const twiml = `
      <Response>
        <Say>This call is recorded. Tell us about your concern.</Say>
        <Record
          maxLength="180"
          action="${process.env.NEXT_PUBLIC_URL}/api/webhooks/twilio/voice/recording"
          transcribe="true"
          transcribeCallback="${process.env.NEXT_PUBLIC_URL}/api/webhooks/twilio/voice/transcription"
        />
      </Response>
    `;

    return new Response(twiml, {
      headers: { 'Content-Type': 'text/xml' },
    });
  } catch (error) {
    const integrationError = handleIntegrationError(error, 'TWILIO', 'voice_webhook');
    logger.error('Error processing Voice webhook', integrationError, {
      source: 'TWILIO',
      action: 'voice_webhook_error',
    });

    const twiml = `
      <Response>
        <Say>We are experiencing technical difficulties. Please try again later.</Say>
      </Response>
    `;
    return new Response(twiml, {
      headers: { 'Content-Type': 'text/xml' },
    });
  }
}

================
File: src/lib/integrations/twilio/client.ts
================
import twilio, { Twilio } from 'twilio';
import { TwilioError } from './types';

export class TwilioClient {
  private static instance: TwilioClient;
  private client: Twilio;

  private constructor() {
    const accountSid = process.env.TWILIO_ACCOUNT_SID;
    const authToken = process.env.TWILIO_AUTH_TOKEN;

    if (!accountSid || !authToken) {
      throw new TwilioError(
        'Missing Twilio credentials',
        'TWILIO_CREDENTIALS_MISSING',
        500
      );
    }

    this.client = twilio(accountSid, authToken);
  }

  public static getInstance(): TwilioClient {
    if (!TwilioClient.instance) {
      TwilioClient.instance = new TwilioClient();
    }
    return TwilioClient.instance;
  }

  public getClient(): Twilio {
    return this.client;
  }
}

export const twilioClient = TwilioClient.getInstance();

================
File: src/lib/integrations/twilio/types.ts
================
import type { IntegrationMetadata } from '../types';

export interface TwilioCallWebhookPayload {
  CallSid: string;
  From: string;
  To: string;
  Direction: 'inbound' | 'outbound';
  CallStatus: string;
  RecordingUrl?: string;
  TranscriptionText?: string;
  Duration?: string;
  [key: string]: any; // To capture additional properties
}

export interface TwilioSMSWebhookPayload {
  MessageSid: string;
  From: string;
  To: string;
  Body: string;
  NumMedia: string;
  MediaUrl0?: string;
  [key: string]: any; // To capture additional properties
}

export interface TwilioMetadata extends IntegrationMetadata {
  source: 'TWILIO';
  mediaUrls?: string[];
  duration?: string;
  status: string;
}

export class TwilioError extends Error {
  constructor(
    message: string,
    public code?: string,
    public status?: number,
    public details?: any
  ) {
    super(message);
    this.name = 'TwilioError';
  }
}

================
File: src/lib/integrations/debug.ts
================
import { logger } from './utils';

export const debugLog = (context: string, data: any) => {
  if (process.env.NODE_ENV === 'development') {
    console.log('\n=== DEBUG:', context, '===');
    console.log(JSON.stringify(data, null, 2));
    console.log('================\n');
  }
};

================
File: src/lib/integrations/errors.ts
================
// src/lib/integrations/errors.ts
export class IntegrationError extends Error {
  constructor(message: string, public code: string, public status: number, public details?: any) {
    super(message);
    this.name = 'IntegrationError';
  }
}

================
File: src/lib/integrations/types.ts
================
export interface IntegrationTokens {
    access_token: string;
    refresh_token?: string;
    expiry_date?: number;
    token_type: string;
    scope?: string;
  }
  
  export class IntegrationError extends Error {
    public code?: string;
    public status?: number;
    public details?: any;
  
    constructor(
      message: string,
      code?: string,
      status?: number,
      details?: any
    ) {
      super(message);
      this.name = 'IntegrationError';
      this.code = code;
      this.status = status;
      this.details = details;
    }
  }
  
  export type IntegrationSource = 'GMAIL' | 'TWILIO';
  
  export interface IntegrationMetadata {
    source: IntegrationSource;
    sourceId: string;
    direction: 'INBOUND' | 'OUTBOUND';
    participants: string[];
    timestamp: string;
    raw?: any;
  }
  
  export interface CommunicationProcessor {
    processIncoming(payload: any, userId?: string): Promise<any>;
    validateWebhook?(request: Request, url: string): Promise<boolean>;
  }
  
  // Additional types for Gmail and Twilio, if needed, can be defined here
  
  export type EmailMetadata = {
    id: string;
    threadId: string;
    subject: string;
    from: string;
    to: string;
    date: string;
    snippet: string;
    labels: string[];
  };
  
  export interface EmailContent {
    id: string;
    threadId: string;
    content: string;
    snippet: string;
    attachments: Array<{
      id: string;
      name: string;
      mimeType: string;
      size: number;
    }>;
  }

================
File: src/lib/integrations/utils.ts
================
// src/lib/integrations/utils.ts

import { IntegrationError } from './errors';

export const logger = {
  info: (message: string, metadata?: any) => {
    console.log(
      JSON.stringify({
        level: 'info',
        timestamp: new Date().toISOString(),
        message,
        ...metadata,
      })
    );
  },

  error: (message: string, error: unknown, metadata?: any) => {
    console.error(
      JSON.stringify({
        level: 'error',
        timestamp: new Date().toISOString(),
        message,
        error: error instanceof Error
          ? {
              name: error.name,
              message: error.message,
              stack: error.stack,
              ...(error instanceof IntegrationError && {
                code: error.code,
                status: error.status,
                details: error.details,
              }),
            }
          : error,
        ...metadata,
      })
    );
  },
};

export function handleIntegrationError(
  error: unknown,
  source?: string,
  action?: string
): IntegrationError {
  if (error instanceof IntegrationError) {
    return error;
  }

  const integrationError = new IntegrationError(
    error instanceof Error ? error.message : 'Unknown integration error',
    'INTEGRATION_ERROR',
    500,
    error
  );

  logger.error(
    `Integration error ${source ? `in ${source}` : ''} ${
      action ? `during ${action}` : ''
    }`,
    integrationError
  );

  return integrationError;
}

export function parseEmailAddress(email: string): {
  email: string;
  name?: string;
} {
  const match = email.match(/(?:"?([^"]*)"?\s)?(?:<?(.+@[^>]+)>?)/);
  if (!match) return { email };
  return {
    name: match[1],
    email: match[2],
  };
}

================
File: src/lib/auth.ts
================
// src/lib/auth.ts

import { auth as clerkAuth } from '@clerk/nextjs/server';

/**
 * Retrieves the authentication information for the current user.
 * @returns An object containing the userId and sessionId.
 */
export async function auth() {
  return clerkAuth();
}

================
File: src/lib/prisma.ts
================
// src/lib/prisma.ts

import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ['query'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/scripts/debug-user.ts
================
// src/scripts/debug-user.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function debugUser() {
  try {
    const user = await prisma.user.findUnique({
      where: {
        id: 'user_2oJLzE9oWUZmN7nAxV2MHJ2W5qJ'
      },
      select: {
        id: true,
        email: true,
        settings: true
      }
    });

    console.log('User Debug Data:', JSON.stringify(user, null, 2));
  } catch (error) {
    console.error('Debug Error:', error);
  } finally {
    await prisma.$disconnect();
  }
}

debugUser();

================
File: src/scripts/dev.ts
================
import { exec } from 'child_process';
import { watch } from 'fs';

function clearNodeCache() {
  console.log(' Clearing Node.js module cache...');
  Object.keys(require.cache).forEach((key) => {
    delete require.cache[key];
  });
}

function restartServer() {
  console.log(' Restarting server...');
  exec('yarn dev', (error, stdout, stderr) => {
    if (error) {
      console.error(' Error:', error);
      return;
    }
    console.log(stdout);
    console.error(stderr);
  });
}

// Watch for changes in src directory
watch('./src', { recursive: true }, (eventType, filename) => {
  if (filename) {
    console.log(` File changed: ${filename}`);
    clearNodeCache();
    restartServer();
  }
});

// Initial start
restartServer();

================
File: src/scripts/reset-db.ts
================
import { prisma } from '@/lib/prisma';

async function resetDatabase() {
  try {
    console.log(' Clearing Communications table...');
    await prisma.communication.deleteMany({});
    
    console.log(' Resetting user tokens...');
    await prisma.user.updateMany({
      where: { email: 'haloweaveinsights@gmail.com' },
      data: {
        settings: {}
      }
    });
    
    console.log(' Database reset complete');
  } catch (error) {
    console.error(' Reset failed:', error);
  } finally {
    await prisma.$disconnect();
  }
}

resetDatabase();

================
File: src/scripts/setup.ts
================
import { prisma } from '../lib/prisma';

async function setup() {
  try {
    // Create default user
    const user = await prisma.user.upsert({
      where: {
        email: 'haloweaveinsights@gmail.com'
      },
      update: {
        role: 'ADMIN'
      },
      create: {
        email: 'haloweaveinsights@gmail.com',
        role: 'ADMIN',
        name: 'Senate Insights Admin'
      }
    });

    console.log('Created/Updated default user:', user);

    // Create default organization
    const organization = await prisma.organization.upsert({
      where: {
        id: 'default-org'
      },
      update: {
        name: 'Senate Insights Organization',
        members: {
          upsert: {
            where: {
              organizationId_userId: {
                organizationId: 'default-org',
                userId: user.id
              }
            },
            update: {
              role: 'OWNER'
            },
            create: {
              userId: user.id,
              role: 'OWNER'
            }
          }
        }
      },
      create: {
        id: 'default-org',
        name: 'Senate Insights Organization',
        members: {
          create: {
            userId: user.id,
            role: 'OWNER'
          }
        }
      }
    });

    console.log('Created/Updated default organization:', organization);

    console.log('Setup completed successfully');
  } catch (error) {
    console.error('Setup failed:', error);
  } finally {
    await prisma.$disconnect();
  }
}

setup();

================
File: src/middleware.ts
================
// src/middleware.ts

import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';

// Define public routes
const isPublicRoute = createRouteMatcher([
  '/',
  '/sign-in(.*)',
  '/sign-up(.*)',
  '/api/webhooks/(.*)',
  '/api/integrations/(.*)',
  '/api/test-call',
  ...(process.env.NODE_ENV === 'development' ? ['/api/test(.*)'] : []),
]);

export default clerkMiddleware(async (auth, request) => {
  // Skip auth for public routes
  if (isPublicRoute(request)) {
    return;
  }

  // Protect all other routes
  const { userId } = await auth.protect();

  // Add request context
  request.headers.set('X-User-Id', userId);
}, {
  publishableKey: process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY, // Ensure this is set
});

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|public/|robots.txt|sitemap.xml).*)',
    '/api/:path*',
  ],
};

================
File: .eslintignore
================
node_modules
.next
out
build
coverage

================
File: .eslintrc.json
================
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "root": true,
  "rules": {
    "@typescript-eslint/no-unused-vars": ["warn", {
      "argsIgnorePattern": "^_",
      "varsIgnorePattern": "^_"
    }],
    "@typescript-eslint/no-explicit-any": "warn"
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files (can opt-in for commiting if needed)
.env
.env.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    ignoreBuildErrors: true,
  },
  eslint: {
    // Warning: This allows production builds to successfully complete even if
    // your project has ESLint errors.
    ignoreDuringBuilds: true,
  },
}

export default nextConfig;

================
File: package.json
================
{
  "name": "senate-insights",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "tunnel": "ngrok http 3000",
    "build": "next build",
    "start": "next start",
    "lint": "next lint --fix",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "type-check": "tsc --noEmit",
    "prisma:generate": "prisma generate",
    "prisma:push": "prisma db push",
    "prisma:studio": "prisma studio",
    "prisma:seed": "ts-node --compiler-options '{\"module\":\"CommonJS\"}' prisma/seed.ts",
    "setup": "tsx src/scripts/setup.ts",
    "dev:watch": "tsx src/scripts/dev.ts",
    "clean": "rm -rf .next && rm -rf node_modules/.cache",
    "dev:fresh": "yarn clean && yarn dev:watch"
  },
  "dependencies": {
    "@apollo/client": "^3.11.8",
    "@clerk/nextjs": "^6.1.0",
    "@hookform/resolvers": "^3.9.1",
    "@prisma/client": "^5.21.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-icons": "^1.3.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.1",
    "@supabase/supabase-js": "^2.46.1",
    "@tanstack/react-query": "^5.59.16",
    "@upstash/redis": "^1.34.3",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "express": "^4.21.1",
    "googleapis": "^144.0.0",
    "graphql-yoga": "^5.8.0",
    "lucide-react": "^0.454.0",
    "next": "15.0.2",
    "prisma": "^5.21.1",
    "react": "19.0.0-rc-02c0e824-20241028",
    "react-dom": "19.0.0-rc-02c0e824-20241028",
    "react-hook-form": "^7.53.1",
    "repomix": "^0.2.1",
    "repopack": "^0.1.45",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "twilio": "^5.3.5",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/node": "^22.8.6",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@typescript-eslint/eslint-plugin": "^8.12.2",
    "@typescript-eslint/parser": "^8.12.2",
    "eslint": "^8",
    "eslint-config-next": "15.0.2",
    "eslint-config-prettier": "^9.1.0",
    "graphql": "^16.0.0",
    "ngrok": "^5.0.0-beta.2",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.2",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: progress-nov-1.md
================
# Senate Insights Progress Tracker - November 1st, 2024

## Architecture and Idea

### Overview
Senate Insights is a communication analytics platform that provides a dual offering:
1. **Public API Service**: A serverless API that developers can use to analyze their communication data
2. **Analytics Dashboard**: A demonstration of our API capabilities through our own insights platform

### System Architecture

#### API Layer (Serverless Functions)
```

   Vercel Edge Network   
                         
      
   API Routes          
   /api/ingest         
   /api/analyze     Client API Calls
   /api/webhooks            (REST/GraphQL)
      

           
           

   Message Processing    
                         
            
   Twilio Webhook    Phone Calls    
   Gmail Webhook               SMS Messages   
   OpenAI Process              Emails         
            

           
           

   Data Storage Layer    
                         
      
     Supabase DB       
     Redis Cache       
      

```

### API Design
1. **REST Endpoints**:
   ```
   POST /api/communications/ingest
   POST /api/communications/analyze
   GET  /api/analytics/metrics
   POST /api/webhooks/twilio
   POST /api/webhooks/gmail
   ```

2. **GraphQL API**:
   ```graphql
   mutation IngestCommunication($input: CommunicationInput!)
   mutation AnalyzeCommunication($id: ID!)
   query GetAnalytics($timeframe: TimeFrame!)
   subscription OnNewAnalysis($filter: AnalysisFilter)
   ```

### Data Flow
1. **Ingestion**:
   - External services send data to our webhooks
   - API clients send data directly to ingest endpoint
   - Data is normalized and queued for processing

2. **Processing**:
   - Serverless functions process queued data
   - OpenAI analyzes content for insights
   - Results are stored in Supabase

3. **Retrieval**:
   - Clients query processed data via API
   - Real-time updates via GraphQL subscriptions
   - Cached results for common queries

## Current Implementation Status
### Completed Features
1. Project Structure Setup
   - Next.js 14 with App Router
   - TypeScript configuration
   - TailwindCSS + shadcn/ui components
   - Proper folder structure with feature separation

2. Authentication System
   - Clerk integration
   - Protected routes setup
   - Auth middleware configuration
   - Login/Signup flows
   - Dashboard protection

3. Basic UI Components
   - Layout system
   - Navigation setup
   - Dashboard skeleton
   - Responsive design
   - Error boundaries
   - Loading states

4. DevOps
   - Vercel deployment
   - Environment variables setup
   - Meta information and SEO
   - Basic error handling

### Day 1 (November 2nd) - Core Infrastructure
- Morning:
  - [ ] Supabase setup and schema design
  - [ ] Prisma configuration
  - [ ] Initial migrations

- Afternoon:
  - [ ] Basic API routes setup
  - [ ] GraphQL schema definition
  - [ ] Authentication middleware

- Evening:
  - [ ] Data models implementation
  - [ ] Basic CRUD operations
  - [ ] API testing setup

### Day 2 (November 3rd) - Integration Services
- Morning:
  - [ ] Twilio webhook setup
  - [ ] SMS handling implementation
  - [ ] Call recording setup

- Afternoon:
  - [ ] Gmail API integration
  - [ ] Email processing
  - [ ] Webhook security

- Evening:
  - [ ] Message queue setup
  - [ ] Basic processing pipeline
  - [ ] Error handling

### Day 3 (November 4th) - AI Processing
- Morning:
  - [ ] OpenAI integration
  - [ ] Content analysis pipeline
  - [ ] Sentiment analysis

- Afternoon:
  - [ ] Entity extraction
  - [ ] Topic categorization
  - [ ] Analysis storage

- Evening:
  - [ ] Cache implementation
  - [ ] Rate limiting
  - [ ] Performance optimization

### Day 4 (November 5th) - Dashboard & Testing
- Morning:
  - [ ] Analytics dashboard components
  - [ ] Real-time updates
  - [ ] Data visualization

- Afternoon:
  - [ ] Testing and bug fixes
  - [ ] Documentation
  - [ ] API example collection

- Evening:
  - [ ] Final deployment
  - [ ] Performance testing
  - [ ] Documentation completion

## Critical Path Items

### Must-Have Features
1. Data Ingestion
   - Basic webhook endpoints
   - Data normalization
   - Storage implementation

2. Processing Pipeline
   - Message queue
   - Basic analysis
   - Result storage

3. API Access
   - Authentication
   - Rate limiting
   - Basic endpoints

4. Dashboard
   - Basic metrics
   - Real-time updates
   - Simple visualizations

### Nice-to-Have Features (If Time Permits)
- Advanced analytics
- Custom reporting
- Export functionality
- Advanced visualizations
- Audit logging
- Advanced security features

## Development Approach

### Parallel Development Strategy
1. **Team Split**:
   - API Development
   - Dashboard Implementation
   - Integration Services

2. **Continuous Integration**:
   - Hourly commits
   - Automated testing
   - Continuous deployment

3. **Risk Mitigation**:
   - Regular backups
   - Feature flags
   - Rollback plans

## Testing Strategy
- Unit tests for critical paths
- Integration tests for APIs
- Basic E2E for core flows
- Performance testing for APIs

## Post-Launch Tasks
- Monitor error rates
- Track API usage
- Gather user feedback
- Plan optimizations
- Document learnings

## Resources & Dependencies
1. API Keys & Credentials
   - Twilio credentials
   - Gmail API keys
   - OpenAI API key
   - Supabase credentials
   - Redis connection details

2. Documentation
   - API documentation
   - Schema documentation
   - Integration guides
   - Deployment guides

3. Testing Resources
   - Test phone numbers
   - Test email accounts
   - Sample datasets
   - Testing environments

================
File: progress-nov-2.md
================
# Senate Insights Progress Tracker - November 1st, 2024

## Project Overview
Senate Insights is a communication analytics platform with two main components:
1. **Public API Service**: A serverless API for communication data analysis
2. **Analytics Dashboard**: A showcase platform demonstrating our API capabilities

## Current Implementation Status

###  Completed
1. **Project Foundation**
   - Next.js 14 with App Router setup
   - TypeScript configuration
   - TailwindCSS + shadcn/ui integration
   - Project structure established
   - Clerk authentication integrated
   - Basic route protection implemented

2. **Database Setup**
   - Supabase connection established
   - Prisma ORM integration
   - Schema design for communications
   - Basic database operations configured

3. **Twilio Integration (In Progress)**
   - Basic webhook structure implemented
   - Voice call endpoint setup
   - SMS endpoint setup
   - Webhook route configuration
   - Basic error handling
   - Waiting for trial number verification

###  In Progress
1. **Twilio Integration (Remaining)**
   - [ ] Verify trial phone numbers
   - [ ] Test voice call functionality
   - [ ] Test SMS functionality
   - [ ] Implement call recording
   - [ ] Add transcription service
   - [ ] Complete error handling
   - [ ] Add logging system

###  Next Steps
1. **Gmail Integration**
   - Set up OAuth for haloweaveinsights@gmail.com
   - Implement email fetching
   - Set up webhook for new emails
   - Handle email attachments
   - Implement token refresh system

2. **AI Analysis Pipeline**
   - OpenAI integration
   - Content analysis system
   - Sentiment analysis
   - Entity extraction
   - Topic categorization

3. **API Development**
   - REST endpoints implementation
   - GraphQL schema setup
   - Authentication system
   - Rate limiting
   - Documentation

4. **Dashboard Development**
   - Analytics components
   - Real-time updates
   - Data visualization
   - User management
   - Settings interface

## Current Architecture

```
Backend Structure:
/src
  /lib
    /integrations
      /twilio          # Current focus
        /handlers
          call.ts
          sms.ts
        client.ts
        types.ts
      /gmail           # Next focus
      /openai          # Future
    /queue            # Pending
    /api              # Pending
    
  /app
    /api
      /webhooks
        /twilio       # Current focus
          /voice
          /sms
        /gmail        # Next focus
      /communications # Future
```

## Environment Setup
```env
# Current Environment Variables
DATABASE_URL="postgresql://..."
DIRECT_URL="postgresql://..."
TWILIO_ACCOUNT_SID="AC93831..."
TWILIO_AUTH_TOKEN="8c2c89..."
TWILIO_PHONE_NUMBER="+14438430495"

# Needed Soon
GMAIL_CLIENT_ID="..."
GMAIL_CLIENT_SECRET="..."
GMAIL_REFRESH_TOKEN="..."
OPENAI_API_KEY="..."
```

## Known Issues
1. Twilio trial account limitations
   - Need to verify phone numbers
   - Limited functionality until upgrade

2. Webhook setup
   - Currently using ngrok for local development
   - Need to handle signature verification properly

## Testing Strategy
1. Current test endpoints:
   - `/api/test-call`: Test voice functionality
   - `/api/webhooks/twilio/test`: Test webhook reception

2. Needed tests:
   - SMS functionality
   - Call recording
   - Email integration
   - AI analysis

## Development Notes
- Using Clerk for authentication
- Webhook URLs must be updated in Twilio console when ngrok restarts
- Environment variables must be properly set in both local and production
- Database schema includes support for future features

## LLM Context Notes
When working with other LLMs:
1. The project uses Next.js 14 App Router
2. Clerk handles authentication
3. Twilio integration is partially complete
4. Schema supports calls, SMS, and emails
5. Project aims for serverless deployment on Vercel
6. Core focus is on communication analysis and insights

## Immediate TODOs
1. Fix Twilio trial number verification
2. Complete SMS and voice testing
3. Begin Gmail API integration
4. Plan AI analysis pipeline
5. Design initial dashboard components

## Resources
- Twilio Console: https://console.twilio.com
- Supabase Dashboard: [Your Supabase URL]
- Gmail API Console: [Pending Setup]
- Project Repository: [Your Repository URL]

## Next Working Session
1. Complete Twilio number verification
2. Test complete communication flow
3. Begin Gmail API setup
4. Plan AI analysis architecture

================
File: project-plan.md
================
# Communication Analytics Platform - Comprehensive Requirements Document

## 1. Project Overview

### 1.1 Purpose
A unified platform that collects, processes, and analyzes communication data (calls, SMS, emails) to provide actionable insights for businesses. The platform combines real-time data ingestion with powerful analytics capabilities.

### 1.2 Core Value Propositions
- Unified communication analytics across multiple channels
- Real-time processing and insights
- AI-powered analysis and categorization
- Actionable business intelligence
- Seamless integration with existing communication tools

## 2. Technical Architecture

### 2.1 Core Technologies
- **Frontend Framework:** Next.js 14 (App Router)
- **Programming Language:** TypeScript (strict mode)
- **Authentication:** Clerk
- **Database:** Supabase (PostgreSQL)
- **API Layer:** GraphQL (graphql-yoga)
- **Styling:** Tailwind CSS + shadcn/ui
- **AI Processing:** OpenAI GPT-4
- **Communication Services:** 
  - Twilio (Calls/SMS)
  - Gmail API (Emails)
- **Message Queue:** Redis
- **Real-time Updates:** GraphQL Subscriptions
- **Monitoring:** OpenTelemetry + Grafana

### 2.2 System Architecture
```
          
  Data Sources          API Gateway             Frontend     
  - Twilio         - GraphQL        - Next.js      
  - Gmail               - REST                - React        
  - Custom Input        - WebSockets          - TailwindCSS  
          
                                                      
                                  
              Message Queue      
                           (Redis)      
                      
                              
                    
                      Processing Layer   
                      - GPT-4 Analysis   
                      - Data Enrichment  
                    
                              
                    
                         Database        
                         (Supabase)      
                    
```

## 3. Feature Specifications

### 3.1 Data Collection & Processing
1. **Communication Ingestion**
   - Twilio webhook integration for calls
     - Call recording storage
     - Automatic transcription
     - Metadata extraction (duration, participants, etc.)
   - Twilio webhook for SMS
     - Content storage
     - Metadata extraction (sender, recipient, timestamp)
   - Gmail API integration
     - Email content processing
     - Attachment handling
     - Thread tracking
     - Metadata extraction

2. **Data Processing Pipeline**
   - Message queue implementation for reliable processing
   - Automatic language detection
   - Content sanitization and normalization
   - Priority classification system
   - Entity extraction
   - Sentiment analysis
   - Topic categorization
   - Custom rules engine for automated tagging

### 3.2 Analytics Dashboard
1. **Real-time Monitoring**
   - Live communication stream
   - Active calls tracking
   - Queue status monitoring
   - System health metrics
   - Error rate tracking

2. **Analytics & Reporting**
   - Communication volume metrics
   - Channel distribution analysis
   - Sentiment trends
   - Response time analytics
   - Geographic distribution
   - Peak time analysis
   - Custom report builder
   - Export capabilities (PDF, CSV, Excel)

3. **Advanced Analytics Features**
   - Predictive analytics for volume forecasting
   - Anomaly detection
   - Pattern recognition
   - Trend analysis
   - Customer journey mapping
   - AI-powered recommendations

### 3.3 User Interface Components
1. **Dashboard Widgets**
   - Communication volume charts
   - Real-time status indicators
   - Sentiment analysis graphs
   - Geographic heat maps
   - Priority distribution charts
   - Category breakdown
   - Top entities word cloud
   - Recent activity feed

2. **Interactive Features**
   - Custom date range selection
   - Advanced filtering system
   - Drag-and-drop dashboard customization
   - Saved filter presets
   - Collaborative annotations
   - Shareable dashboard links

## 4. Data Models

### 4.1 Core Database Schema
```typescript
interface User {
  id: string;
  email: string;
  role: 'ADMIN' | 'USER' | 'VIEWER';
  settings: JsonObject;
  createdAt: Date;
  updatedAt: Date;
}

interface Communication {
  id: string;
  type: 'CALL' | 'SMS' | 'EMAIL';
  direction: 'INBOUND' | 'OUTBOUND';
  rawContent: string;
  processedContent: string;
  metadata: {
    source: string;
    sourceId: string;
    participants: string[];
    timestamp: Date;
    duration?: number;
    location?: GeoPoint;
    labels?: string[];
    customFields?: Record<string, any>;
  };
  status: 'PENDING' | 'PROCESSING' | 'PROCESSED' | 'FAILED';
  errorDetails?: string;
  createdAt: Date;
  updatedAt: Date;
}

interface Analysis {
  id: string;
  communicationId: string;
  version: string;
  sentiment: {
    score: number;
    magnitude: number;
    labels: string[];
  };
  summary: string;
  categories: Category[];
  priority: number;
  entities: Entity[];
  intentions: string[];
  language: string;
  confidence: number;
  processingTime: number;
  createdAt: Date;
}

interface Category {
  id: string;
  name: string;
  confidence: number;
  parentId?: string;
}

interface Entity {
  id: string;
  type: string;
  name: string;
  confidence: number;
  metadata: Record<string, any>;
}
```

### 4.2 GraphQL Schema
```graphql
type Communication {
  id: ID!
  type: CommunicationType!
  direction: Direction!
  rawContent: String!
  processedContent: String!
  metadata: CommunicationMetadata!
  analysis: Analysis
  status: ProcessingStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Analysis {
  id: ID!
  communicationId: ID!
  version: String!
  sentiment: Sentiment!
  summary: String!
  categories: [Category!]!
  priority: Int!
  entities: [Entity!]!
  intentions: [String!]!
  language: String!
  confidence: Float!
  processingTime: Int!
  createdAt: DateTime!
}

type Query {
  communications(
    filter: CommunicationFilter
    pagination: PaginationInput
  ): CommunicationConnection!
  
  analytics(
    timeframe: TimeFrame!
    filters: AnalyticsFilter
  ): AnalyticsData!
  
  dashboardMetrics(
    timeframe: TimeFrame!
  ): DashboardMetrics!
}

type Mutation {
  reprocessCommunication(id: ID!): Communication!
  updateCommunicationStatus(id: ID!, status: ProcessingStatus!): Communication!
  createCustomCategory(input: CategoryInput!): Category!
}

type Subscription {
  onNewCommunication: Communication!
  onAnalysisComplete: Analysis!
  onStatusUpdate: CommunicationStatus!
}
```

## 5. Technical Requirements

### 5.1 Performance Requirements
- Page load time < 2 seconds
- API response time < 500ms
- Real-time updates latency < 100ms
- Support for 100,000 communications per day
- Handle 1000 concurrent users
- 99.9% uptime SLA

### 5.2 Security Requirements
- OAuth 2.0 authentication
- Role-based access control
- API rate limiting
- Data encryption at rest
- SSL/TLS encryption
- Regular security audits
- GDPR compliance
- Data retention policies

### 5.3 Scalability Requirements
- Horizontal scaling capability
- Microservices architecture
- Caching strategy
- Load balancing
- Database sharding strategy
- CDN integration

## 6. Development & Deployment

### 6.1 Development Guidelines
- Git workflow (trunk-based development)
- Code review process
- Testing requirements
- Documentation standards
- Coding style guide
- Performance benchmarks
- Security guidelines

### 6.2 Testing Strategy
- Unit testing (Jest)
- Integration testing
- E2E testing (Playwright)
- Performance testing
- Security testing
- API testing
- Load testing

### 6.3 Deployment Strategy
- CI/CD pipeline (GitHub Actions)
- Environment management
- Database migrations
- Rollback procedures
- Monitoring setup
- Backup procedures

### 6.4 Monitoring & Maintenance
- Error tracking (Sentry)
- Performance monitoring
- Usage analytics
- API metrics
- Health checks
- Automated alerts
- Backup verification

## 7. Project Phases

### 7.1 Phase 1: Core Infrastructure (Weeks 1-4)
- Project setup and configuration
- Authentication implementation
- Database setup and migrations
- Basic API structure
- Communication ingestion endpoints
- Initial dashboard setup

### 7.2 Phase 2: Data Processing (Weeks 5-8)
- Message queue implementation
- GPT-4 integration
- Data processing pipeline
- Analysis storage
- Basic analytics implementation

### 7.3 Phase 3: Analytics & UI (Weeks 9-12)
- Advanced analytics features
- Dashboard components
- Real-time updates
- Custom reports
- Export functionality

### 7.4 Phase 4: Enhancement & Optimization (Weeks 13-16)
- Performance optimization
- Security hardening
- Advanced features
- Testing & bug fixes
- Documentation
- Deployment preparation

## 8. Success Metrics

### 8.1 Technical Metrics
- System uptime > 99.9%
- API response time < 500ms
- Processing pipeline throughput
- Error rate < 0.1%
- Test coverage > 80%

### 8.2 Business Metrics
- User engagement metrics
- Processing accuracy
- Customer satisfaction
- Feature adoption rate
- System reliability

## 9. Future Considerations

### 9.1 Potential Extensions
- Mobile application
- Custom AI models
- Additional communication channels
- Advanced automation features
- Integration marketplace
- White-label solutions

### 9.2 Scaling Considerations
- Multi-region deployment
- Enhanced caching strategies
- Database sharding
- Load balancing improvements
- Content delivery optimization

================
File: README.md
================
# Communication Analytics Platform 

> Real-time communication analytics platform powered by AI. Process, analyze, and derive insights from calls, SMS, and emails.

## Features 

-  Real-time phone call transcription and analysis
-  SMS message processing and categorization
-  Email integration via Gmail API
-  AI-powered sentiment analysis and categorization
-  GraphQL API for data access
-  Analytics dashboard
-  Real-time updates and notifications

## Tech Stack 

- **Frontend**: Next.js 14 (App Router)
- **Backend**: Vercel Serverless Functions
- **Database**: Supabase (PostgreSQL)
- **API**: GraphQL with graphql-yoga
- **AI**: GPT-4
- **Communication**: Twilio (Voice + SMS)
- **Email**: Gmail API
- **Authentication**: Supabase Auth
- **Styling**: Tailwind CSS + shadcn/ui

## Architecture 

```mermaid
flowchart TB
    subgraph Input["Data Sources"]
        TW[Twilio Service]
        GM[Gmail API]
        DD[Demo Data Generator]
    end

    subgraph Serverless["Vercel"]
        subgraph API["API Routes"]
            TWH[Twilio Webhook]
            GWH[Gmail Webhook]
            DEM[Demo Data Endpoint]
        end
        
        subgraph Process["Processing"]
            AI[GPT-4 Analysis]
            PARSE[Data Parser]
        end
        
        subgraph GraphQL["API Layer"]
            GQ[GraphQL Endpoint]
        end
    end

    subgraph Storage["Supabase"]
        COM[Communications]
        ANA[Analysis]
        META[Metadata]
    end

    TW -->|Webhooks| TWH
    GM -->|Push Notifications| GWH
    DD -->|Bulk Load| DEM
    
    TWH & GWH & DEM --> PARSE
    PARSE --> AI
    AI --> Storage
    
    Storage --> GQ
```

## Prerequisites 

You'll need accounts and API keys for:

- [Twilio](https://www.twilio.com/) (~$20 initial credit)
- [OpenAI](https://openai.com/) (~$20 initial credit)
- [Google Cloud Console](https://console.cloud.google.com/) (Gmail API)
- [Supabase](https://supabase.com/) (Free tier)
- [Vercel](https://vercel.com/) (Free tier)

## Getting Started 

1. **Clone the repository**
```bash
git clone https://github.com/yourusername/communication-analytics.git
cd communication-analytics
```

2. **Install dependencies**
```bash
npm install
```

3. **Set up environment variables**
```bash
cp .env.example .env.local
```

Required environment variables:
```env
# API Keys
TWILIO_ACCOUNT_SID=xxx
TWILIO_AUTH_TOKEN=xxx
OPENAI_API_KEY=xxx

# Database
SUPABASE_URL=xxx
SUPABASE_ANON_KEY=xxx

# Google API
GOOGLE_CLIENT_ID=xxx
GOOGLE_CLIENT_SECRET=xxx
```

4. **Run development server**
```bash
npm run dev
```

## Project Structure 

```
project/
 app/                  # Next.js app router
    api/             # API routes
    dashboard/       # Dashboard pages
    layout.tsx       # Root layout
 components/          # React components
 lib/                 # Utility functions
    ai/             # AI processing
    db/             # Database operations
    api/            # API utilities
 types/              # TypeScript types
 prisma/             # Database schema
```

## Database Schema 

```typescript
// Key type definitions
type Communication = {
  id: string;              // UUID
  channel: Channel;        // CALL | SMS | EMAIL
  rawContent: string;      // Original content/transcript
  metadata: {
    source: string;        // Phone number/email
    location?: string;     // State code
    duration?: number;     // For calls
    timestamp: Date;
  };
  analysis?: Analysis;     // Linked analysis
  createdAt: Date;
  updatedAt: Date;
};
```

## API Examples 

### GraphQL Queries

```graphql
# Fetch communications with analysis
query GetCommunications {
  communications(
    filter: {
      channel: CALL,
      startDate: "2024-01-01"
    }
  ) {
    id
    rawContent
    analysis {
      sentiment
      category
    }
  }
}
```

## Development Timeline 

### MVP (5 Days)
- **Day 1**: Setup & Infrastructure
- **Day 2**: Demo Data Generation
- **Day 3**: Core Processing
- **Day 4**: API & Query Layer
- **Day 5**: Testing & Dashboard

## Testing 

### Generate Demo Data

```bash
# Generate test data
npm run generate-demo-data

# Run tests
npm test
```

## Deployment 

The application is configured for deployment on Vercel:

1. Push to GitHub
2. Connect repository to Vercel
3. Configure environment variables
4. Deploy!

## Contributing 

1. Fork the repository
2. Create feature branch (`git checkout -b feature/amazing-feature`)
3. Commit changes (`git commit -m 'Add amazing feature'`)
4. Push to branch (`git push origin feature/amazing-feature`)
5. Open Pull Request

## License 

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Support 

For support, email haloweave@gmail.com or open an issue.

## Roadmap 

- [x] MVP Features
- [ ] Enhanced Analytics
- [ ] Real-time Dashboard
- [ ] Mobile App
- [ ] Export Features
- [ ] Advanced Search

---

Made with  by Haloweave

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================
File: tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: vercel.json
================
{
    "build": {
      "env": {
        "NEXT_TELEMETRY_DISABLED": "1"
      }
    },
    "github": {
      "silent": true
    }
  }
